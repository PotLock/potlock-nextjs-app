/**
 * Generated by orval v6.30.2 üç∫
 * Do not edit manually.
 * PotLock Indexer API dev
 * Indexed data for the PotLock protocol
 * OpenAPI spec version: 1.0.0
 */
import axios from "axios";
import type { AxiosError, AxiosRequestConfig, AxiosResponse } from "axios";
import useSwr from "swr";
import type { Key, SWRConfiguration } from "swr";
export type V1ListsRandomRegistrationRetrieveParams = {
  /**
   * Filter registrations by status
   */
  status?: string;
};

export type V1DonorsRetrieveParams = {
  /**
   * Sort by field, e.g., most_donated_usd
   */
  sort?: string;
};

export type V1AccountsPotApplicationsRetrieveParams = {
  /**
   * Filter pot applications by status
   */
  status?: string;
};

export type V1AccountsActivePotsRetrieveParams = {
  /**
   * Filter by pot status
   */
  status?: string;
};

export interface Token {
  /**
   * Token decimals.
   * @minimum 0
   * @maximum 2147483647
   */
  decimals: number;
  /**
   * Token icon (base64 data URL).
   * @nullable
   */
  icon?: string | null;
  /** Token ID (address). */
  id: string;
  /**
   * Token name.
   * @maxLength 255
   * @nullable
   */
  name?: string | null;
  /**
   * Token symbol.
   * @maxLength 255
   * @nullable
   */
  symbol?: string | null;
}

/**
 * * `Pending` - Pending
 * `Approved` - Approved
 * `Rejected` - Rejected
 * `Graylisted` - Graylisted
 * `Blacklisted` - Blacklisted
 */
export type StatusF24Enum = (typeof StatusF24Enum)[keyof typeof StatusF24Enum];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const StatusF24Enum = {
  Pending: "Pending",
  Approved: "Approved",
  Rejected: "Rejected",
  Graylisted: "Graylisted",
  Blacklisted: "Blacklisted",
} as const;

export interface StatsResponse {
  total_donations_count: number;
  total_donations_usd: number;
  total_donors_count: number;
  total_payouts_usd: number;
  total_recipients_count: number;
}

/**
 * * `Pending` - Pending
 * `Approved` - Approved
 * `Rejected` - Rejected
 * `InReview` - InReview
 */
export type PotApplicationStatusEnum =
  (typeof PotApplicationStatusEnum)[keyof typeof PotApplicationStatusEnum];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PotApplicationStatusEnum = {
  Pending: "Pending",
  Approved: "Approved",
  Rejected: "Rejected",
  InReview: "InReview",
} as const;

export interface Pot {
  admins: Account[];
  /** All paid out. */
  all_paid_out: boolean;
  /** Pot application end date. */
  application_end: string;
  /** Pot application start date. */
  application_start: string;
  /**
   * Base currency.
   * @maxLength 64
   * @nullable
   */
  base_currency?: string | null;
  chef: Account;
  /**
   * Chef fee basis points.
   * @minimum 0
   * @maximum 2147483647
   */
  chef_fee_basis_points: number;
  /**
   * Pot cooldown end date.
   * @nullable
   */
  cooldown_end?: string | null;
  /**
   * Pot cooldown period in ms.
   * @minimum 0
   * @maximum 2147483647
   * @nullable
   */
  cooldown_period_ms?: number | null;
  /**
   * Custom min threshold score.
   * @minimum 0
   * @maximum 2147483647
   * @nullable
   */
  custom_min_threshold_score?: number | null;
  /**
   * Custom sybil checks.
   * @nullable
   */
  custom_sybil_checks?: string | null;
  /** Pot deployment date. */
  deployed_at: string;
  deployer: Account;
  /** Pot description. */
  description: string;
  /** Pot account ID. */
  id: string;
  /** Matching pool balance. */
  matching_pool_balance: string;
  /**
   * Matching pool donations count.
   * @minimum 0
   * @maximum 2147483647
   */
  matching_pool_donations_count: number;
  /** Pot matching round end date. */
  matching_round_end: string;
  /** Pot matching round start date. */
  matching_round_start: string;
  /**
   * Max approved applicants.
   * @minimum 0
   * @maximum 2147483647
   */
  max_approved_applicants: number;
  /** Min matching pool donation amount. */
  min_matching_pool_donation_amount: string;
  /** Pot name. */
  name: string;
  owner: Account;
  /** Pot factory. */
  pot_factory: string;
  /**
   * Protocol config provider.
   * @nullable
   */
  protocol_config_provider?: string | null;
  /**
   * Public donations count.
   * @minimum 0
   * @maximum 2147483647
   */
  public_donations_count: number;
  /**
   * Referral fee matching pool basis points.
   * @minimum 0
   * @maximum 2147483647
   */
  referral_fee_matching_pool_basis_points: number;
  /**
   * Referral fee public round basis points.
   * @minimum 0
   * @maximum 2147483647
   */
  referral_fee_public_round_basis_points: number;
  /**
   * Registry provider.
   * @nullable
   */
  registry_provider?: string | null;
  /** Pot source metadata. */
  source_metadata: unknown;
  /**
   * Sybil wrapper provider.
   * @nullable
   */
  sybil_wrapper_provider?: string | null;
  /** Total matching pool. */
  total_matching_pool: string;
  /** @pattern ^-?\d{0,18}(?:\.\d{0,2})?$ */
  total_matching_pool_usd: string;
  /** Total public donations. */
  total_public_donations: string;
  /** @pattern ^-?\d{0,18}(?:\.\d{0,2})?$ */
  total_public_donations_usd: string;
}

export interface PotPayout {
  /** Payout amount. */
  amount: string;
  /**
   * Payout amount in USD.
   * @nullable
   * @pattern ^-?\d{0,18}(?:\.\d{0,2})?$
   */
  amount_paid_usd?: string | null;
  /** Payout id. */
  readonly id: number;
  /** Payout date. */
  paid_at: string;
  pot: Pot;
  recipient: Account;
  token: Token;
  /**
   * Transaction hash.
   * @nullable
   */
  tx_hash?: string | null;
}

export interface PotApplication {
  applicant: Account;
  /** Application id. */
  readonly id: number;
  /**
   * Application message.
   * @maxLength 1024
   * @nullable
   */
  message?: string | null;
  pot: Pot;
  /** Application status.

* `Pending` - Pending
* `Approved` - Approved
* `Rejected` - Rejected
* `InReview` - InReview */
  status: PotApplicationStatusEnum;
  /** Application submission date. */
  submitted_at: string;
  /**
   * Transaction hash.
   * @nullable
   */
  tx_hash?: string | null;
  /**
   * Application last update date.
   * @nullable
   */
  updated_at?: string | null;
}

export interface PaginatedPotsResponse {
  count: number;
  /** @nullable */
  next: string | null;
  /** @nullable */
  previous: string | null;
  results: Pot[];
}

export interface PaginatedPotPayoutsResponse {
  count: number;
  /** @nullable */
  next: string | null;
  /** @nullable */
  previous: string | null;
  results: PotPayout[];
}

export interface PaginatedPotApplicationsResponse {
  count: number;
  /** @nullable */
  next: string | null;
  /** @nullable */
  previous: string | null;
  results: PotApplication[];
}

export interface PaginatedListsResponse {
  count: number;
  /** @nullable */
  next: string | null;
  /** @nullable */
  previous: string | null;
  results: List[];
}

export interface PaginatedListRegistrationsResponse {
  count: number;
  /** @nullable */
  next: string | null;
  /** @nullable */
  previous: string | null;
  results: ListRegistration[];
}

export interface PaginatedDonationsResponse {
  count: number;
  /** @nullable */
  next: string | null;
  /** @nullable */
  previous: string | null;
  results: Donation[];
}

export interface PaginatedAccountsResponse {
  count: number;
  /** @nullable */
  next: string | null;
  /** @nullable */
  previous: string | null;
  results: Account[];
}

export interface Nft {
  baseUri?: string;
  contractId?: string;
  media?: string;
  tokenId?: string;
}

export interface List {
  /** Admin only registrations. */
  admin_only_registrations: boolean;
  admins: Account[];
  /**
   * Cover image url.
   * @maxLength 200
   * @nullable
   */
  cover_image_url?: string | null;
  /** List creation date. */
  created_at: string;
  /** Default registration status.

* `Pending` - Pending
* `Approved` - Approved
* `Rejected` - Rejected
* `Graylisted` - Graylisted
* `Blacklisted` - Blacklisted */
  default_registration_status: DefaultRegistrationStatusEnum;
  /**
   * List description.
   * @maxLength 256
   * @nullable
   */
  description?: string | null;
  /** List ID in DB (does not necessarily correspond to on-chain ID). */
  readonly id: number;
  /**
   * List name.
   * @maxLength 64
   */
  name: string;
  /**
   * List ID in contract
   * @minimum -2147483648
   * @maximum 2147483647
   */
  on_chain_id: number;
  owner: Account;
  /** List last update date. */
  updated_at: string;
}

export interface ListRegistration {
  /**
   * Admin notes.
   * @maxLength 1024
   * @nullable
   */
  admin_notes?: string | null;
  /** Registration id. */
  readonly id: number;
  list: List;
  registered_by: Account;
  registrant: Account;
  /**
   * Registrant notes.
   * @maxLength 1024
   * @nullable
   */
  registrant_notes?: string | null;
  /** Registration status.

* `Pending` - Pending
* `Approved` - Approved
* `Rejected` - Rejected
* `Graylisted` - Graylisted
* `Blacklisted` - Blacklisted */
  status: StatusF24Enum;
  /** Registration submission date. */
  submitted_at: string;
  /**
   * Transaction hash.
   * @maxLength 64
   * @nullable
   */
  tx_hash?: string | null;
  /** Registration last update date. */
  updated_at: string;
}

export interface Linktree {
  github?: string;
  telegram?: string;
  twitter?: string;
  website?: string;
}

export interface Image {
  ipfs_cid?: string;
  nft?: Nft;
  url?: string;
}

export interface NearSocialProfileData {
  backgroundImage?: Image;
  description?: string;
  image?: Image;
  linktree?: Linktree;
  name?: string;
  /** JSON-stringified array of category strings */
  plCategories?: string;
  /** JSON-stringified array of funding source objects */
  plFundingSources?: string;
  /** JSON-stringified array of URLs */
  plGithubRepos?: string;
  plPublicGoodReason?: string;
  /** JSON-stringified object with chain names as keys that map to nested objects of contract addresses */
  plSmartContracts?: string;
  /** JSON-stringified array of team member account ID strings */
  plTeam?: string;
}

export interface DonationContractConfig {
  owner: string;
  protocol_fee_basis_points: number;
  protocol_fee_recipient_account: string;
  referral_fee_basis_points: number;
}

export interface Donation {
  chef: Account;
  /**
   * Chef fee.
   * @maxLength 64
   * @nullable
   */
  chef_fee?: string | null;
  /**
   * Chef fee in USD.
   * @nullable
   * @pattern ^-?\d{0,18}(?:\.\d{0,2})?$
   */
  chef_fee_usd?: string | null;
  /** Donation date. */
  donated_at: string;
  donor: Account;
  /** Donation id. */
  readonly id: number;
  /** Matching pool. */
  matching_pool: boolean;
  /**
   * Donation message.
   * @maxLength 1024
   * @nullable
   */
  message?: string | null;
  /**
   * Net amount.
   * @maxLength 64
   */
  net_amount: string;
  /**
   * Net amount in USD.
   * @nullable
   * @pattern ^-?\d{0,18}(?:\.\d{0,2})?$
   */
  net_amount_usd?: string | null;
  /**
   * Donation id in contract
   * @minimum -2147483648
   * @maximum 2147483647
   */
  on_chain_id: number;
  pot: Pot;
  /**
   * Protocol fee.
   * @maxLength 64
   */
  protocol_fee: string;
  /**
   * Protocol fee in USD.
   * @nullable
   * @pattern ^-?\d{0,18}(?:\.\d{0,2})?$
   */
  protocol_fee_usd?: string | null;
  recipient: Account;
  referrer: Account;
  /**
   * Referrer fee.
   * @maxLength 64
   * @nullable
   */
  referrer_fee?: string | null;
  /**
   * Referrer fee in USD.
   * @nullable
   * @pattern ^-?\d{0,18}(?:\.\d{0,2})?$
   */
  referrer_fee_usd?: string | null;
  token: Token;
  /**
   * Total amount.
   * @maxLength 64
   */
  total_amount: string;
  /**
   * Total amount in USD.
   * @nullable
   * @pattern ^-?\d{0,18}(?:\.\d{0,2})?$
   */
  total_amount_usd?: string | null;
  /**
   * Transaction hash.
   * @maxLength 64
   * @nullable
   */
  tx_hash?: string | null;
}

/**
 * * `Pending` - Pending
 * `Approved` - Approved
 * `Rejected` - Rejected
 * `Graylisted` - Graylisted
 * `Blacklisted` - Blacklisted
 */
export type DefaultRegistrationStatusEnum =
  (typeof DefaultRegistrationStatusEnum)[keyof typeof DefaultRegistrationStatusEnum];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DefaultRegistrationStatusEnum = {
  Pending: "Pending",
  Approved: "Approved",
  Rejected: "Rejected",
  Graylisted: "Graylisted",
  Blacklisted: "Blacklisted",
} as const;

export interface Account {
  donors_count: number;
  /**
   * On-chain account address.
   * @maxLength 64
   */
  id: string;
  near_social_profile_data?: NearSocialProfileData;
  /**
   * @minimum -1000000000000000000
   * @maximum 1000000000000000000
   * @exclusiveMinimum
   * @exclusiveMaximum
   */
  total_donations_in_usd: number;
  /**
   * @minimum -1000000000000000000
   * @maximum 1000000000000000000
   * @exclusiveMinimum
   * @exclusiveMaximum
   */
  total_donations_out_usd: number;
  /**
   * @minimum -1000000000000000000
   * @maximum 1000000000000000000
   * @exclusiveMinimum
   * @exclusiveMaximum
   */
  total_matching_pool_allocations_usd: number;
}

export const v1AccountsRetrieve = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedAccountsResponse>> => {
  return axios.get(`/api/v1/accounts`, options);
};

export const getV1AccountsRetrieveKey = () => [`/api/v1/accounts`] as const;

export type V1AccountsRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof v1AccountsRetrieve>>
>;
export type V1AccountsRetrieveQueryError = AxiosError<void>;

export const useV1AccountsRetrieve = <TError = AxiosError<void>>(options?: {
  swr?: SWRConfiguration<
    Awaited<ReturnType<typeof v1AccountsRetrieve>>,
    TError
  > & { swrKey?: Key; enabled?: boolean };
  axios?: AxiosRequestConfig;
}) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey =
    swrOptions?.swrKey ??
    (() => (isEnabled ? getV1AccountsRetrieveKey() : null));
  const swrFn = () => v1AccountsRetrieve(axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

export const v1AccountsRetrieve2 = (
  accountId: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<Account>> => {
  return axios.get(`/api/v1/accounts/${accountId}`, options);
};

export const getV1AccountsRetrieve2Key = (accountId: string) =>
  [`/api/v1/accounts/${accountId}`] as const;

export type V1AccountsRetrieve2QueryResult = NonNullable<
  Awaited<ReturnType<typeof v1AccountsRetrieve2>>
>;
export type V1AccountsRetrieve2QueryError = AxiosError<void>;

export const useV1AccountsRetrieve2 = <TError = AxiosError<void>>(
  accountId: string,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof v1AccountsRetrieve2>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
    axios?: AxiosRequestConfig;
  },
) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!accountId;
  const swrKey =
    swrOptions?.swrKey ??
    (() => (isEnabled ? getV1AccountsRetrieve2Key(accountId) : null));
  const swrFn = () => v1AccountsRetrieve2(accountId, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

export const v1AccountsActivePotsRetrieve = (
  accountId: string,
  params?: V1AccountsActivePotsRetrieveParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedPotsResponse>> => {
  return axios.get(`/api/v1/accounts/${accountId}/active_pots`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getV1AccountsActivePotsRetrieveKey = (
  accountId: string,
  params?: V1AccountsActivePotsRetrieveParams,
) =>
  [
    `/api/v1/accounts/${accountId}/active_pots`,
    ...(params ? [params] : []),
  ] as const;

export type V1AccountsActivePotsRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof v1AccountsActivePotsRetrieve>>
>;
export type V1AccountsActivePotsRetrieveQueryError = AxiosError<void>;

export const useV1AccountsActivePotsRetrieve = <TError = AxiosError<void>>(
  accountId: string,
  params?: V1AccountsActivePotsRetrieveParams,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof v1AccountsActivePotsRetrieve>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
    axios?: AxiosRequestConfig;
  },
) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!accountId;
  const swrKey =
    swrOptions?.swrKey ??
    (() =>
      isEnabled ? getV1AccountsActivePotsRetrieveKey(accountId, params) : null);
  const swrFn = () =>
    v1AccountsActivePotsRetrieve(accountId, params, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

export const v1AccountsDonationsReceivedRetrieve = (
  accountId: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedDonationsResponse>> => {
  return axios.get(`/api/v1/accounts/${accountId}/donations_received`, options);
};

export const getV1AccountsDonationsReceivedRetrieveKey = (accountId: string) =>
  [`/api/v1/accounts/${accountId}/donations_received`] as const;

export type V1AccountsDonationsReceivedRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof v1AccountsDonationsReceivedRetrieve>>
>;
export type V1AccountsDonationsReceivedRetrieveQueryError = AxiosError<void>;

export const useV1AccountsDonationsReceivedRetrieve = <
  TError = AxiosError<void>,
>(
  accountId: string,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof v1AccountsDonationsReceivedRetrieve>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
    axios?: AxiosRequestConfig;
  },
) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!accountId;
  const swrKey =
    swrOptions?.swrKey ??
    (() =>
      isEnabled ? getV1AccountsDonationsReceivedRetrieveKey(accountId) : null);
  const swrFn = () =>
    v1AccountsDonationsReceivedRetrieve(accountId, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

export const v1AccountsDonationsSentRetrieve = (
  accountId: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedDonationsResponse>> => {
  return axios.get(`/api/v1/accounts/${accountId}/donations_sent`, options);
};

export const getV1AccountsDonationsSentRetrieveKey = (accountId: string) =>
  [`/api/v1/accounts/${accountId}/donations_sent`] as const;

export type V1AccountsDonationsSentRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof v1AccountsDonationsSentRetrieve>>
>;
export type V1AccountsDonationsSentRetrieveQueryError = AxiosError<void>;

export const useV1AccountsDonationsSentRetrieve = <TError = AxiosError<void>>(
  accountId: string,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof v1AccountsDonationsSentRetrieve>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
    axios?: AxiosRequestConfig;
  },
) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!accountId;
  const swrKey =
    swrOptions?.swrKey ??
    (() =>
      isEnabled ? getV1AccountsDonationsSentRetrieveKey(accountId) : null);
  const swrFn = () => v1AccountsDonationsSentRetrieve(accountId, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

export const v1AccountsPayoutsReceivedRetrieve = (
  accountId: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedPotPayoutsResponse>> => {
  return axios.get(`/api/v1/accounts/${accountId}/payouts_received`, options);
};

export const getV1AccountsPayoutsReceivedRetrieveKey = (accountId: string) =>
  [`/api/v1/accounts/${accountId}/payouts_received`] as const;

export type V1AccountsPayoutsReceivedRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof v1AccountsPayoutsReceivedRetrieve>>
>;
export type V1AccountsPayoutsReceivedRetrieveQueryError = AxiosError<void>;

export const useV1AccountsPayoutsReceivedRetrieve = <TError = AxiosError<void>>(
  accountId: string,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof v1AccountsPayoutsReceivedRetrieve>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
    axios?: AxiosRequestConfig;
  },
) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!accountId;
  const swrKey =
    swrOptions?.swrKey ??
    (() =>
      isEnabled ? getV1AccountsPayoutsReceivedRetrieveKey(accountId) : null);
  const swrFn = () =>
    v1AccountsPayoutsReceivedRetrieve(accountId, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

export const v1AccountsPotApplicationsRetrieve = (
  accountId: string,
  params?: V1AccountsPotApplicationsRetrieveParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedPotApplicationsResponse>> => {
  return axios.get(`/api/v1/accounts/${accountId}/pot_applications`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getV1AccountsPotApplicationsRetrieveKey = (
  accountId: string,
  params?: V1AccountsPotApplicationsRetrieveParams,
) =>
  [
    `/api/v1/accounts/${accountId}/pot_applications`,
    ...(params ? [params] : []),
  ] as const;

export type V1AccountsPotApplicationsRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof v1AccountsPotApplicationsRetrieve>>
>;
export type V1AccountsPotApplicationsRetrieveQueryError = AxiosError<void>;

export const useV1AccountsPotApplicationsRetrieve = <TError = AxiosError<void>>(
  accountId: string,
  params?: V1AccountsPotApplicationsRetrieveParams,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof v1AccountsPotApplicationsRetrieve>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
    axios?: AxiosRequestConfig;
  },
) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!accountId;
  const swrKey =
    swrOptions?.swrKey ??
    (() =>
      isEnabled
        ? getV1AccountsPotApplicationsRetrieveKey(accountId, params)
        : null);
  const swrFn = () =>
    v1AccountsPotApplicationsRetrieve(accountId, params, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

export const v1DonateContractConfigRetrieve = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<DonationContractConfig>> => {
  return axios.get(`/api/v1/donate_contract_config`, options);
};

export const getV1DonateContractConfigRetrieveKey = () =>
  [`/api/v1/donate_contract_config`] as const;

export type V1DonateContractConfigRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof v1DonateContractConfigRetrieve>>
>;
export type V1DonateContractConfigRetrieveQueryError = AxiosError<void>;

export const useV1DonateContractConfigRetrieve = <
  TError = AxiosError<void>,
>(options?: {
  swr?: SWRConfiguration<
    Awaited<ReturnType<typeof v1DonateContractConfigRetrieve>>,
    TError
  > & { swrKey?: Key; enabled?: boolean };
  axios?: AxiosRequestConfig;
}) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey =
    swrOptions?.swrKey ??
    (() => (isEnabled ? getV1DonateContractConfigRetrieveKey() : null));
  const swrFn = () => v1DonateContractConfigRetrieve(axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

export const v1DonorsRetrieve = (
  params?: V1DonorsRetrieveParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedAccountsResponse>> => {
  return axios.get(`/api/v1/donors`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getV1DonorsRetrieveKey = (params?: V1DonorsRetrieveParams) =>
  [`/api/v1/donors`, ...(params ? [params] : [])] as const;

export type V1DonorsRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof v1DonorsRetrieve>>
>;
export type V1DonorsRetrieveQueryError = AxiosError<void>;

export const useV1DonorsRetrieve = <TError = AxiosError<void>>(
  params?: V1DonorsRetrieveParams,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof v1DonorsRetrieve>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
    axios?: AxiosRequestConfig;
  },
) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey =
    swrOptions?.swrKey ??
    (() => (isEnabled ? getV1DonorsRetrieveKey(params) : null));
  const swrFn = () => v1DonorsRetrieve(params, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

export const v1ListsRetrieve = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedListsResponse>> => {
  return axios.get(`/api/v1/lists`, options);
};

export const getV1ListsRetrieveKey = () => [`/api/v1/lists`] as const;

export type V1ListsRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof v1ListsRetrieve>>
>;
export type V1ListsRetrieveQueryError = AxiosError<void>;

export const useV1ListsRetrieve = <TError = AxiosError<void>>(options?: {
  swr?: SWRConfiguration<
    Awaited<ReturnType<typeof v1ListsRetrieve>>,
    TError
  > & { swrKey?: Key; enabled?: boolean };
  axios?: AxiosRequestConfig;
}) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey =
    swrOptions?.swrKey ?? (() => (isEnabled ? getV1ListsRetrieveKey() : null));
  const swrFn = () => v1ListsRetrieve(axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

export const v1ListsRetrieve2 = (
  listId: number,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<List>> => {
  return axios.get(`/api/v1/lists/${listId}`, options);
};

export const getV1ListsRetrieve2Key = (listId: number) =>
  [`/api/v1/lists/${listId}`] as const;

export type V1ListsRetrieve2QueryResult = NonNullable<
  Awaited<ReturnType<typeof v1ListsRetrieve2>>
>;
export type V1ListsRetrieve2QueryError = AxiosError<void>;

export const useV1ListsRetrieve2 = <TError = AxiosError<void>>(
  listId: number,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof v1ListsRetrieve2>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
    axios?: AxiosRequestConfig;
  },
) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!listId;
  const swrKey =
    swrOptions?.swrKey ??
    (() => (isEnabled ? getV1ListsRetrieve2Key(listId) : null));
  const swrFn = () => v1ListsRetrieve2(listId, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

export const v1ListsRandomRegistrationRetrieve = (
  listId: number,
  params?: V1ListsRandomRegistrationRetrieveParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<ListRegistration>> => {
  return axios.get(`/api/v1/lists/${listId}/random_registration`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getV1ListsRandomRegistrationRetrieveKey = (
  listId: number,
  params?: V1ListsRandomRegistrationRetrieveParams,
) =>
  [
    `/api/v1/lists/${listId}/random_registration`,
    ...(params ? [params] : []),
  ] as const;

export type V1ListsRandomRegistrationRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof v1ListsRandomRegistrationRetrieve>>
>;
export type V1ListsRandomRegistrationRetrieveQueryError = AxiosError<void>;

export const useV1ListsRandomRegistrationRetrieve = <TError = AxiosError<void>>(
  listId: number,
  params?: V1ListsRandomRegistrationRetrieveParams,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof v1ListsRandomRegistrationRetrieve>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
    axios?: AxiosRequestConfig;
  },
) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!listId;
  const swrKey =
    swrOptions?.swrKey ??
    (() =>
      isEnabled
        ? getV1ListsRandomRegistrationRetrieveKey(listId, params)
        : null);
  const swrFn = () =>
    v1ListsRandomRegistrationRetrieve(listId, params, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

export const v1ListsRegistrationsRetrieve = (
  listId: number,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedListRegistrationsResponse>> => {
  return axios.get(`/api/v1/lists/${listId}/registrations`, options);
};

export const getV1ListsRegistrationsRetrieveKey = (listId: number) =>
  [`/api/v1/lists/${listId}/registrations`] as const;

export type V1ListsRegistrationsRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof v1ListsRegistrationsRetrieve>>
>;
export type V1ListsRegistrationsRetrieveQueryError = AxiosError<void>;

export const useV1ListsRegistrationsRetrieve = <TError = AxiosError<void>>(
  listId: number,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof v1ListsRegistrationsRetrieve>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
    axios?: AxiosRequestConfig;
  },
) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!listId;
  const swrKey =
    swrOptions?.swrKey ??
    (() => (isEnabled ? getV1ListsRegistrationsRetrieveKey(listId) : null));
  const swrFn = () => v1ListsRegistrationsRetrieve(listId, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

export const v1PotsRetrieve = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedPotsResponse>> => {
  return axios.get(`/api/v1/pots`, options);
};

export const getV1PotsRetrieveKey = () => [`/api/v1/pots`] as const;

export type V1PotsRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof v1PotsRetrieve>>
>;
export type V1PotsRetrieveQueryError = AxiosError<unknown>;

export const useV1PotsRetrieve = <TError = AxiosError<unknown>>(options?: {
  swr?: SWRConfiguration<Awaited<ReturnType<typeof v1PotsRetrieve>>, TError> & {
    swrKey?: Key;
    enabled?: boolean;
  };
  axios?: AxiosRequestConfig;
}) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey =
    swrOptions?.swrKey ?? (() => (isEnabled ? getV1PotsRetrieveKey() : null));
  const swrFn = () => v1PotsRetrieve(axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

export const v1PotsRetrieve2 = (
  potId: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<Pot>> => {
  return axios.get(`/api/v1/pots/${potId}/`, options);
};

export const getV1PotsRetrieve2Key = (potId: string) =>
  [`/api/v1/pots/${potId}/`] as const;

export type V1PotsRetrieve2QueryResult = NonNullable<
  Awaited<ReturnType<typeof v1PotsRetrieve2>>
>;
export type V1PotsRetrieve2QueryError = AxiosError<void>;

export const useV1PotsRetrieve2 = <TError = AxiosError<void>>(
  potId: string,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof v1PotsRetrieve2>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
    axios?: AxiosRequestConfig;
  },
) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!potId;
  const swrKey =
    swrOptions?.swrKey ??
    (() => (isEnabled ? getV1PotsRetrieve2Key(potId) : null));
  const swrFn = () => v1PotsRetrieve2(potId, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

export const v1PotsApplicationsRetrieve = (
  potId: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedPotApplicationsResponse>> => {
  return axios.get(`/api/v1/pots/${potId}/applications`, options);
};

export const getV1PotsApplicationsRetrieveKey = (potId: string) =>
  [`/api/v1/pots/${potId}/applications`] as const;

export type V1PotsApplicationsRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof v1PotsApplicationsRetrieve>>
>;
export type V1PotsApplicationsRetrieveQueryError = AxiosError<void>;

export const useV1PotsApplicationsRetrieve = <TError = AxiosError<void>>(
  potId: string,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof v1PotsApplicationsRetrieve>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
    axios?: AxiosRequestConfig;
  },
) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!potId;
  const swrKey =
    swrOptions?.swrKey ??
    (() => (isEnabled ? getV1PotsApplicationsRetrieveKey(potId) : null));
  const swrFn = () => v1PotsApplicationsRetrieve(potId, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

export const v1PotsDonationsRetrieve = (
  potId: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedDonationsResponse>> => {
  return axios.get(`/api/v1/pots/${potId}/donations`, options);
};

export const getV1PotsDonationsRetrieveKey = (potId: string) =>
  [`/api/v1/pots/${potId}/donations`] as const;

export type V1PotsDonationsRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof v1PotsDonationsRetrieve>>
>;
export type V1PotsDonationsRetrieveQueryError = AxiosError<void>;

export const useV1PotsDonationsRetrieve = <TError = AxiosError<void>>(
  potId: string,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof v1PotsDonationsRetrieve>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
    axios?: AxiosRequestConfig;
  },
) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!potId;
  const swrKey =
    swrOptions?.swrKey ??
    (() => (isEnabled ? getV1PotsDonationsRetrieveKey(potId) : null));
  const swrFn = () => v1PotsDonationsRetrieve(potId, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

export const v1PotsPayoutsRetrieve = (
  potId: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedPotPayoutsResponse>> => {
  return axios.get(`/api/v1/pots/${potId}/payouts`, options);
};

export const getV1PotsPayoutsRetrieveKey = (potId: string) =>
  [`/api/v1/pots/${potId}/payouts`] as const;

export type V1PotsPayoutsRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof v1PotsPayoutsRetrieve>>
>;
export type V1PotsPayoutsRetrieveQueryError = AxiosError<void>;

export const useV1PotsPayoutsRetrieve = <TError = AxiosError<void>>(
  potId: string,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof v1PotsPayoutsRetrieve>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
    axios?: AxiosRequestConfig;
  },
) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!potId;
  const swrKey =
    swrOptions?.swrKey ??
    (() => (isEnabled ? getV1PotsPayoutsRetrieveKey(potId) : null));
  const swrFn = () => v1PotsPayoutsRetrieve(potId, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

export const v1PotsSponsorsRetrieve = (
  potId: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedAccountsResponse>> => {
  return axios.get(`/api/v1/pots/${potId}/sponsors`, options);
};

export const getV1PotsSponsorsRetrieveKey = (potId: string) =>
  [`/api/v1/pots/${potId}/sponsors`] as const;

export type V1PotsSponsorsRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof v1PotsSponsorsRetrieve>>
>;
export type V1PotsSponsorsRetrieveQueryError = AxiosError<void>;

export const useV1PotsSponsorsRetrieve = <TError = AxiosError<void>>(
  potId: string,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof v1PotsSponsorsRetrieve>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
    axios?: AxiosRequestConfig;
  },
) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!potId;
  const swrKey =
    swrOptions?.swrKey ??
    (() => (isEnabled ? getV1PotsSponsorsRetrieveKey(potId) : null));
  const swrFn = () => v1PotsSponsorsRetrieve(potId, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

export const v1StatsRetrieve = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<StatsResponse>> => {
  return axios.get(`/api/v1/stats`, options);
};

export const getV1StatsRetrieveKey = () => [`/api/v1/stats`] as const;

export type V1StatsRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof v1StatsRetrieve>>
>;
export type V1StatsRetrieveQueryError = AxiosError<void>;

export const useV1StatsRetrieve = <TError = AxiosError<void>>(options?: {
  swr?: SWRConfiguration<
    Awaited<ReturnType<typeof v1StatsRetrieve>>,
    TError
  > & { swrKey?: Key; enabled?: boolean };
  axios?: AxiosRequestConfig;
}) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey =
    swrOptions?.swrKey ?? (() => (isEnabled ? getV1StatsRetrieveKey() : null));
  const swrFn = () => v1StatsRetrieve(axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};
