/**
 * Generated by orval v6.30.2 üç∫
 * Do not edit manually.
 * PotLock Indexer API dev
 * Indexed data for the PotLock protocol
 * OpenAPI spec version: 1.0.0
 */
import axios from 'axios'
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios'
import useSwr from 'swr'
import type {
  Key,
  SWRConfiguration
} from 'swr'
export type V1DonorsRetrieveParams = {
/**
 * Sort by field, e.g., most_donated_usd
 */
sort?: string;
};

export type V1AccountsActivePotsRetrieveParams = {
/**
 * Filter by pot status
 */
status?: string;
};

/**
 * * `Pending` - Pending
* `Approved` - Approved
* `Rejected` - Rejected
* `Graylisted` - Graylisted
* `Blacklisted` - Blacklisted
 */
export type StatusF24Enum = typeof StatusF24Enum[keyof typeof StatusF24Enum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const StatusF24Enum = {
  Pending: 'Pending',
  Approved: 'Approved',
  Rejected: 'Rejected',
  Graylisted: 'Graylisted',
  Blacklisted: 'Blacklisted',
} as const;

export interface StatsResponse {
  total_donations_count: number;
  total_donations_usd: number;
  total_donors_count: number;
  total_payouts_usd: number;
  total_recipients_count: number;
}

export interface PotPayout {
  /** Payout amount. */
  amount: string;
  /**
   * Payout amount in USD.
   * @nullable
   * @pattern ^-?\d{0,18}(?:\.\d{0,2})?$
   */
  amount_paid_usd?: string | null;
  /** Payout FT. */
  ft: string;
  /** Payout id. */
  readonly id: number;
  /** Payout date. */
  paid_at: string;
  /** Pot that this payout is for. */
  pot: string;
  /** Payout recipient. */
  recipient: string;
  /**
   * Transaction hash.
   * @nullable
   */
  tx_hash?: string | null;
}

/**
 * * `Pending` - Pending
* `Approved` - Approved
* `Rejected` - Rejected
* `InReview` - InReview
 */
export type PotApplicationStatusEnum = typeof PotApplicationStatusEnum[keyof typeof PotApplicationStatusEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PotApplicationStatusEnum = {
  Pending: 'Pending',
  Approved: 'Approved',
  Rejected: 'Rejected',
  InReview: 'InReview',
} as const;

export interface PotApplication {
  /** Account that applied to the pot. */
  applicant: string;
  /** Application id. */
  readonly id: number;
  /**
   * Application message.
   * @maxLength 1024
   * @nullable
   */
  message?: string | null;
  readonly pot: string;
  /** Application status.

* `Pending` - Pending
* `Approved` - Approved
* `Rejected` - Rejected
* `InReview` - InReview */
  status: PotApplicationStatusEnum;
  /** Application submission date. */
  submitted_at: string;
  /**
   * Transaction hash.
   * @nullable
   */
  tx_hash?: string | null;
  /**
   * Application last update date.
   * @nullable
   */
  updated_at?: string | null;
}

export interface Pot {
  /** Pot admins. */
  admins: string[];
  /** All paid out. */
  all_paid_out: boolean;
  /** Pot application end date. */
  application_end: string;
  /** Pot application start date. */
  application_start: string;
  /**
   * Base currency.
   * @maxLength 64
   * @nullable
   */
  base_currency?: string | null;
  /**
   * Pot chef.
   * @nullable
   */
  chef?: string | null;
  /**
   * Chef fee basis points.
   * @minimum 0
   * @maximum 2147483647
   */
  chef_fee_basis_points: number;
  /**
   * Pot cooldown end date.
   * @nullable
   */
  cooldown_end?: string | null;
  /**
   * Pot cooldown period in ms.
   * @minimum 0
   * @maximum 2147483647
   * @nullable
   */
  cooldown_period_ms?: number | null;
  /**
   * Custom min threshold score.
   * @minimum 0
   * @maximum 2147483647
   * @nullable
   */
  custom_min_threshold_score?: number | null;
  /**
   * Custom sybil checks.
   * @nullable
   */
  custom_sybil_checks?: string | null;
  /** Pot deployment date. */
  deployed_at: string;
  /** Pot deployer. */
  deployer: string;
  /** Pot description. */
  description: string;
  /** Pot account ID. */
  id: string;
  /** Matching pool balance. */
  matching_pool_balance: string;
  /**
   * Matching pool donations count.
   * @minimum 0
   * @maximum 2147483647
   */
  matching_pool_donations_count: number;
  /** Pot matching round end date. */
  matching_round_end: string;
  /** Pot matching round start date. */
  matching_round_start: string;
  /**
   * Max approved applicants.
   * @minimum 0
   * @maximum 2147483647
   */
  max_approved_applicants: number;
  /** Min matching pool donation amount. */
  min_matching_pool_donation_amount: string;
  /** Pot name. */
  name: string;
  /** Pot owner. */
  owner: string;
  /** Pot factory. */
  pot_factory: string;
  /**
   * Protocol config provider.
   * @nullable
   */
  protocol_config_provider?: string | null;
  /**
   * Public donations count.
   * @minimum 0
   * @maximum 2147483647
   */
  public_donations_count: number;
  /**
   * Referral fee matching pool basis points.
   * @minimum 0
   * @maximum 2147483647
   */
  referral_fee_matching_pool_basis_points: number;
  /**
   * Referral fee public round basis points.
   * @minimum 0
   * @maximum 2147483647
   */
  referral_fee_public_round_basis_points: number;
  /**
   * Registry provider.
   * @nullable
   */
  registry_provider?: string | null;
  /** Pot source metadata. */
  source_metadata: unknown;
  /**
   * Sybil wrapper provider.
   * @nullable
   */
  sybil_wrapper_provider?: string | null;
  /** Total matching pool. */
  total_matching_pool: string;
  /** @pattern ^-?\d{0,18}(?:\.\d{0,2})?$ */
  total_matching_pool_usd: string;
  /** Total public donations. */
  total_public_donations: string;
  /** @pattern ^-?\d{0,18}(?:\.\d{0,2})?$ */
  total_public_donations_usd: string;
}

export interface NearSocialProfileData {
  backgroundImage?: Image;
  description?: string;
  image?: Image;
  linktree?: Linktree;
  name?: string;
  /** JSON-stringified array of category strings */
  plCategories?: string;
  /** JSON-stringified array of funding source objects */
  plFundingSources?: string;
  /** JSON-stringified array of URLs */
  plGithubRepos?: string;
  plPublicGoodReason?: string;
  /** JSON-stringified object with chain names as keys that map to nested objects of contract addresses */
  plSmartContracts?: string;
  /** JSON-stringified array of team member account ID strings */
  plTeam?: string;
}

export interface Nft {
  baseUri?: string;
  contractId?: string;
  media?: string;
  tokenId?: string;
}

export interface ListRegistration {
  /**
   * Admin notes.
   * @maxLength 1024
   * @nullable
   */
  admin_notes?: string | null;
  /** Registration id. */
  readonly id: number;
  /** List registered. */
  list: number;
  /** Account that did the registration. */
  registered_by: string;
  /** Account that registered on the list. */
  registrant: string;
  /**
   * Registrant notes.
   * @maxLength 1024
   * @nullable
   */
  registrant_notes?: string | null;
  /** Registration status.

* `Pending` - Pending
* `Approved` - Approved
* `Rejected` - Rejected
* `Graylisted` - Graylisted
* `Blacklisted` - Blacklisted */
  status: StatusF24Enum;
  /** Registration submission date. */
  submitted_at: string;
  /**
   * Transaction hash.
   * @maxLength 64
   * @nullable
   */
  tx_hash?: string | null;
  /** Registration last update date. */
  updated_at: string;
}

export interface List {
  /** Admin only registrations. */
  admin_only_registrations: boolean;
  /** List admins. */
  admins: string[];
  /**
   * Cover image url.
   * @maxLength 200
   * @nullable
   */
  cover_image_url?: string | null;
  /** List creation date. */
  created_at: string;
  /** Default registration status.

* `Pending` - Pending
* `Approved` - Approved
* `Rejected` - Rejected
* `Graylisted` - Graylisted
* `Blacklisted` - Blacklisted */
  default_registration_status: DefaultRegistrationStatusEnum;
  /**
   * List description.
   * @maxLength 256
   * @nullable
   */
  description?: string | null;
  /** List ID in DB (does not necessarily correspond to on-chain ID). */
  readonly id: number;
  /**
   * List name.
   * @maxLength 64
   */
  name: string;
  /**
   * List ID in contract
   * @minimum -2147483648
   * @maximum 2147483647
   */
  on_chain_id: number;
  /** List owner. */
  owner: string;
  /** List last update date. */
  updated_at: string;
}

export interface Linktree {
  github?: string;
  telegram?: string;
  twitter?: string;
  website?: string;
}

export interface Image {
  ipfs_cid?: string;
  nft?: Nft;
  url?: string;
}

export interface Donation {
  /**
   * Donation chef.
   * @nullable
   */
  chef?: string | null;
  /**
   * Chef fee.
   * @maxLength 64
   * @nullable
   */
  chef_fee?: string | null;
  /**
   * Chef fee in USD.
   * @nullable
   * @pattern ^-?\d{0,18}(?:\.\d{0,2})?$
   */
  chef_fee_usd?: string | null;
  /** Donation date. */
  donated_at: string;
  /** Donor. */
  donor: string;
  /** Donation FT. */
  ft: string;
  /** Donation id. */
  readonly id: number;
  /** Matching pool. */
  matching_pool: boolean;
  /**
   * Donation message.
   * @maxLength 1024
   * @nullable
   */
  message?: string | null;
  /**
   * Net amount.
   * @maxLength 64
   */
  net_amount: string;
  /**
   * Net amount in USD.
   * @nullable
   * @pattern ^-?\d{0,18}(?:\.\d{0,2})?$
   */
  net_amount_usd?: string | null;
  /**
   * Donation id in contract
   * @minimum -2147483648
   * @maximum 2147483647
   */
  on_chain_id: number;
  /**
   * Donation pot.
   * @nullable
   */
  pot: string | null;
  /**
   * Protocol fee.
   * @maxLength 64
   */
  protocol_fee: string;
  /**
   * Protocol fee in USD.
   * @nullable
   * @pattern ^-?\d{0,18}(?:\.\d{0,2})?$
   */
  protocol_fee_usd?: string | null;
  /**
   * Donation recipient.
   * @nullable
   */
  recipient?: string | null;
  /**
   * Donation referrer.
   * @nullable
   */
  referrer?: string | null;
  /**
   * Referrer fee.
   * @maxLength 64
   * @nullable
   */
  referrer_fee?: string | null;
  /**
   * Referrer fee in USD.
   * @nullable
   * @pattern ^-?\d{0,18}(?:\.\d{0,2})?$
   */
  referrer_fee_usd?: string | null;
  /**
   * Total amount.
   * @maxLength 64
   */
  total_amount: string;
  /**
   * Total amount in USD.
   * @nullable
   * @pattern ^-?\d{0,18}(?:\.\d{0,2})?$
   */
  total_amount_usd?: string | null;
  /**
   * Transaction hash.
   * @maxLength 64
   * @nullable
   */
  tx_hash?: string | null;
}

/**
 * * `Pending` - Pending
* `Approved` - Approved
* `Rejected` - Rejected
* `Graylisted` - Graylisted
* `Blacklisted` - Blacklisted
 */
export type DefaultRegistrationStatusEnum = typeof DefaultRegistrationStatusEnum[keyof typeof DefaultRegistrationStatusEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DefaultRegistrationStatusEnum = {
  Pending: 'Pending',
  Approved: 'Approved',
  Rejected: 'Rejected',
  Graylisted: 'Graylisted',
  Blacklisted: 'Blacklisted',
} as const;

export interface Account {
  donors_count: number;
  /**
   * On-chain account address.
   * @maxLength 64
   */
  id: string;
  near_social_profile_data?: NearSocialProfileData;
  /**
   * @minimum -1000000000000000000
   * @maximum 1000000000000000000
   * @exclusiveMinimum
   * @exclusiveMaximum
   */
  total_donations_in_usd: number;
  /**
   * @minimum -1000000000000000000
   * @maximum 1000000000000000000
   * @exclusiveMinimum
   * @exclusiveMaximum
   */
  total_donations_out_usd: number;
  /**
   * @minimum -1000000000000000000
   * @maximum 1000000000000000000
   * @exclusiveMinimum
   * @exclusiveMaximum
   */
  total_matching_pool_allocations_usd: number;
}




  
  export const v1AccountsRetrieve = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Account[]>> => {
    return axios.get(
      `/api/v1/accounts`,options
    );
  }



export const getV1AccountsRetrieveKey = () => [`/api/v1/accounts`] as const;


export type V1AccountsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1AccountsRetrieve>>>
export type V1AccountsRetrieveQueryError = AxiosError<void>

export const useV1AccountsRetrieve = <TError = AxiosError<void>>(
   options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof v1AccountsRetrieve>>, TError> & { swrKey?: Key, enabled?: boolean }, axios?: AxiosRequestConfig }
) => {
  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getV1AccountsRetrieveKey() : null);
  const swrFn = () => v1AccountsRetrieve(axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

export const v1AccountsRetrieve2 = (
    accountId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Account>> => {
    return axios.get(
      `/api/v1/accounts/${accountId}`,options
    );
  }



export const getV1AccountsRetrieve2Key = (accountId: string,) => [`/api/v1/accounts/${accountId}`] as const;


export type V1AccountsRetrieve2QueryResult = NonNullable<Awaited<ReturnType<typeof v1AccountsRetrieve2>>>
export type V1AccountsRetrieve2QueryError = AxiosError<void>

export const useV1AccountsRetrieve2 = <TError = AxiosError<void>>(
  accountId: string, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof v1AccountsRetrieve2>>, TError> & { swrKey?: Key, enabled?: boolean }, axios?: AxiosRequestConfig }
) => {
  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false && !!(accountId)
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getV1AccountsRetrieve2Key(accountId) : null);
  const swrFn = () => v1AccountsRetrieve2(accountId, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

export const v1AccountsActivePotsRetrieve = (
    accountId: string,
    params?: V1AccountsActivePotsRetrieveParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Pot[]>> => {
    return axios.get(
      `/api/v1/accounts/${accountId}/active_pots`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getV1AccountsActivePotsRetrieveKey = (accountId: string,
    params?: V1AccountsActivePotsRetrieveParams,) => [`/api/v1/accounts/${accountId}/active_pots`, ...(params ? [params]: [])] as const;


export type V1AccountsActivePotsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1AccountsActivePotsRetrieve>>>
export type V1AccountsActivePotsRetrieveQueryError = AxiosError<void>

export const useV1AccountsActivePotsRetrieve = <TError = AxiosError<void>>(
  accountId: string,
    params?: V1AccountsActivePotsRetrieveParams, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof v1AccountsActivePotsRetrieve>>, TError> & { swrKey?: Key, enabled?: boolean }, axios?: AxiosRequestConfig }
) => {
  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false && !!(accountId)
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getV1AccountsActivePotsRetrieveKey(accountId,params) : null);
  const swrFn = () => v1AccountsActivePotsRetrieve(accountId,params, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

export const v1AccountsDonationsReceivedRetrieve = (
    accountId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Donation[]>> => {
    return axios.get(
      `/api/v1/accounts/${accountId}/donations_received`,options
    );
  }



export const getV1AccountsDonationsReceivedRetrieveKey = (accountId: string,) => [`/api/v1/accounts/${accountId}/donations_received`] as const;


export type V1AccountsDonationsReceivedRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1AccountsDonationsReceivedRetrieve>>>
export type V1AccountsDonationsReceivedRetrieveQueryError = AxiosError<void>

export const useV1AccountsDonationsReceivedRetrieve = <TError = AxiosError<void>>(
  accountId: string, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof v1AccountsDonationsReceivedRetrieve>>, TError> & { swrKey?: Key, enabled?: boolean }, axios?: AxiosRequestConfig }
) => {
  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false && !!(accountId)
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getV1AccountsDonationsReceivedRetrieveKey(accountId) : null);
  const swrFn = () => v1AccountsDonationsReceivedRetrieve(accountId, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

export const v1AccountsDonationsSentRetrieve = (
    accountId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Donation[]>> => {
    return axios.get(
      `/api/v1/accounts/${accountId}/donations_sent`,options
    );
  }



export const getV1AccountsDonationsSentRetrieveKey = (accountId: string,) => [`/api/v1/accounts/${accountId}/donations_sent`] as const;


export type V1AccountsDonationsSentRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1AccountsDonationsSentRetrieve>>>
export type V1AccountsDonationsSentRetrieveQueryError = AxiosError<void>

export const useV1AccountsDonationsSentRetrieve = <TError = AxiosError<void>>(
  accountId: string, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof v1AccountsDonationsSentRetrieve>>, TError> & { swrKey?: Key, enabled?: boolean }, axios?: AxiosRequestConfig }
) => {
  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false && !!(accountId)
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getV1AccountsDonationsSentRetrieveKey(accountId) : null);
  const swrFn = () => v1AccountsDonationsSentRetrieve(accountId, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

export const v1AccountsPotApplicationsRetrieve = (
    accountId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PotApplication[]>> => {
    return axios.get(
      `/api/v1/accounts/${accountId}/pot_applications`,options
    );
  }



export const getV1AccountsPotApplicationsRetrieveKey = (accountId: string,) => [`/api/v1/accounts/${accountId}/pot_applications`] as const;


export type V1AccountsPotApplicationsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1AccountsPotApplicationsRetrieve>>>
export type V1AccountsPotApplicationsRetrieveQueryError = AxiosError<void>

export const useV1AccountsPotApplicationsRetrieve = <TError = AxiosError<void>>(
  accountId: string, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof v1AccountsPotApplicationsRetrieve>>, TError> & { swrKey?: Key, enabled?: boolean }, axios?: AxiosRequestConfig }
) => {
  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false && !!(accountId)
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getV1AccountsPotApplicationsRetrieveKey(accountId) : null);
  const swrFn = () => v1AccountsPotApplicationsRetrieve(accountId, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

export const v1DonorsRetrieve = (
    params?: V1DonorsRetrieveParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Account[]>> => {
    return axios.get(
      `/api/v1/donors`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getV1DonorsRetrieveKey = (params?: V1DonorsRetrieveParams,) => [`/api/v1/donors`, ...(params ? [params]: [])] as const;


export type V1DonorsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1DonorsRetrieve>>>
export type V1DonorsRetrieveQueryError = AxiosError<void>

export const useV1DonorsRetrieve = <TError = AxiosError<void>>(
  params?: V1DonorsRetrieveParams, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof v1DonorsRetrieve>>, TError> & { swrKey?: Key, enabled?: boolean }, axios?: AxiosRequestConfig }
) => {
  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getV1DonorsRetrieveKey(params) : null);
  const swrFn = () => v1DonorsRetrieve(params, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

export const v1ListsRetrieve = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<List[]>> => {
    return axios.get(
      `/api/v1/lists`,options
    );
  }



export const getV1ListsRetrieveKey = () => [`/api/v1/lists`] as const;


export type V1ListsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1ListsRetrieve>>>
export type V1ListsRetrieveQueryError = AxiosError<void>

export const useV1ListsRetrieve = <TError = AxiosError<void>>(
   options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof v1ListsRetrieve>>, TError> & { swrKey?: Key, enabled?: boolean }, axios?: AxiosRequestConfig }
) => {
  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getV1ListsRetrieveKey() : null);
  const swrFn = () => v1ListsRetrieve(axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

export const v1ListsRetrieve2 = (
    listId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<List>> => {
    return axios.get(
      `/api/v1/lists/${listId}`,options
    );
  }



export const getV1ListsRetrieve2Key = (listId: number,) => [`/api/v1/lists/${listId}`] as const;


export type V1ListsRetrieve2QueryResult = NonNullable<Awaited<ReturnType<typeof v1ListsRetrieve2>>>
export type V1ListsRetrieve2QueryError = AxiosError<void>

export const useV1ListsRetrieve2 = <TError = AxiosError<void>>(
  listId: number, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof v1ListsRetrieve2>>, TError> & { swrKey?: Key, enabled?: boolean }, axios?: AxiosRequestConfig }
) => {
  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false && !!(listId)
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getV1ListsRetrieve2Key(listId) : null);
  const swrFn = () => v1ListsRetrieve2(listId, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

export const v1ListsRegistrationsRetrieve = (
    listId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListRegistration[]>> => {
    return axios.get(
      `/api/v1/lists/${listId}/registrations`,options
    );
  }



export const getV1ListsRegistrationsRetrieveKey = (listId: number,) => [`/api/v1/lists/${listId}/registrations`] as const;


export type V1ListsRegistrationsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1ListsRegistrationsRetrieve>>>
export type V1ListsRegistrationsRetrieveQueryError = AxiosError<void>

export const useV1ListsRegistrationsRetrieve = <TError = AxiosError<void>>(
  listId: number, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof v1ListsRegistrationsRetrieve>>, TError> & { swrKey?: Key, enabled?: boolean }, axios?: AxiosRequestConfig }
) => {
  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false && !!(listId)
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getV1ListsRegistrationsRetrieveKey(listId) : null);
  const swrFn = () => v1ListsRegistrationsRetrieve(listId, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

export const v1PotsRetrieve = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Pot[]>> => {
    return axios.get(
      `/api/v1/pots`,options
    );
  }



export const getV1PotsRetrieveKey = () => [`/api/v1/pots`] as const;


export type V1PotsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1PotsRetrieve>>>
export type V1PotsRetrieveQueryError = AxiosError<unknown>

export const useV1PotsRetrieve = <TError = AxiosError<unknown>>(
   options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof v1PotsRetrieve>>, TError> & { swrKey?: Key, enabled?: boolean }, axios?: AxiosRequestConfig }
) => {
  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getV1PotsRetrieveKey() : null);
  const swrFn = () => v1PotsRetrieve(axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

export const v1PotsRetrieve2 = (
    potId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Pot>> => {
    return axios.get(
      `/api/v1/pots/${potId}/`,options
    );
  }



export const getV1PotsRetrieve2Key = (potId: string,) => [`/api/v1/pots/${potId}/`] as const;


export type V1PotsRetrieve2QueryResult = NonNullable<Awaited<ReturnType<typeof v1PotsRetrieve2>>>
export type V1PotsRetrieve2QueryError = AxiosError<void>

export const useV1PotsRetrieve2 = <TError = AxiosError<void>>(
  potId: string, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof v1PotsRetrieve2>>, TError> & { swrKey?: Key, enabled?: boolean }, axios?: AxiosRequestConfig }
) => {
  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false && !!(potId)
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getV1PotsRetrieve2Key(potId) : null);
  const swrFn = () => v1PotsRetrieve2(potId, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

export const v1PotsApplicationsRetrieve = (
    potId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PotApplication[]>> => {
    return axios.get(
      `/api/v1/pots/${potId}/applications`,options
    );
  }



export const getV1PotsApplicationsRetrieveKey = (potId: string,) => [`/api/v1/pots/${potId}/applications`] as const;


export type V1PotsApplicationsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1PotsApplicationsRetrieve>>>
export type V1PotsApplicationsRetrieveQueryError = AxiosError<void>

export const useV1PotsApplicationsRetrieve = <TError = AxiosError<void>>(
  potId: string, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof v1PotsApplicationsRetrieve>>, TError> & { swrKey?: Key, enabled?: boolean }, axios?: AxiosRequestConfig }
) => {
  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false && !!(potId)
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getV1PotsApplicationsRetrieveKey(potId) : null);
  const swrFn = () => v1PotsApplicationsRetrieve(potId, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

export const v1PotsDonationsRetrieve = (
    potId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Donation[]>> => {
    return axios.get(
      `/api/v1/pots/${potId}/donations`,options
    );
  }



export const getV1PotsDonationsRetrieveKey = (potId: string,) => [`/api/v1/pots/${potId}/donations`] as const;


export type V1PotsDonationsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1PotsDonationsRetrieve>>>
export type V1PotsDonationsRetrieveQueryError = AxiosError<void>

export const useV1PotsDonationsRetrieve = <TError = AxiosError<void>>(
  potId: string, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof v1PotsDonationsRetrieve>>, TError> & { swrKey?: Key, enabled?: boolean }, axios?: AxiosRequestConfig }
) => {
  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false && !!(potId)
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getV1PotsDonationsRetrieveKey(potId) : null);
  const swrFn = () => v1PotsDonationsRetrieve(potId, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

export const v1PotsPayoutsRetrieve = (
    potId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PotPayout[]>> => {
    return axios.get(
      `/api/v1/pots/${potId}/payouts`,options
    );
  }



export const getV1PotsPayoutsRetrieveKey = (potId: string,) => [`/api/v1/pots/${potId}/payouts`] as const;


export type V1PotsPayoutsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1PotsPayoutsRetrieve>>>
export type V1PotsPayoutsRetrieveQueryError = AxiosError<void>

export const useV1PotsPayoutsRetrieve = <TError = AxiosError<void>>(
  potId: string, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof v1PotsPayoutsRetrieve>>, TError> & { swrKey?: Key, enabled?: boolean }, axios?: AxiosRequestConfig }
) => {
  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false && !!(potId)
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getV1PotsPayoutsRetrieveKey(potId) : null);
  const swrFn = () => v1PotsPayoutsRetrieve(potId, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

export const v1PotsSponsorsRetrieve = (
    potId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Account[]>> => {
    return axios.get(
      `/api/v1/pots/${potId}/sponsors`,options
    );
  }



export const getV1PotsSponsorsRetrieveKey = (potId: string,) => [`/api/v1/pots/${potId}/sponsors`] as const;


export type V1PotsSponsorsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1PotsSponsorsRetrieve>>>
export type V1PotsSponsorsRetrieveQueryError = AxiosError<void>

export const useV1PotsSponsorsRetrieve = <TError = AxiosError<void>>(
  potId: string, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof v1PotsSponsorsRetrieve>>, TError> & { swrKey?: Key, enabled?: boolean }, axios?: AxiosRequestConfig }
) => {
  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false && !!(potId)
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getV1PotsSponsorsRetrieveKey(potId) : null);
  const swrFn = () => v1PotsSponsorsRetrieve(potId, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

export const v1StatsRetrieve = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<StatsResponse>> => {
    return axios.get(
      `/api/v1/stats`,options
    );
  }



export const getV1StatsRetrieveKey = () => [`/api/v1/stats`] as const;


export type V1StatsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1StatsRetrieve>>>
export type V1StatsRetrieveQueryError = AxiosError<void>

export const useV1StatsRetrieve = <TError = AxiosError<void>>(
   options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof v1StatsRetrieve>>, TError> & { swrKey?: Key, enabled?: boolean }, axios?: AxiosRequestConfig }
) => {
  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getV1StatsRetrieveKey() : null);
  const swrFn = () => v1StatsRetrieve(axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

