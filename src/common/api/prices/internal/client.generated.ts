/**
 * Generated by orval v6.31.0 üç∫
 * Do not edit manually.
 * Intear Token Indexer API
 * Generated by Claude
 * OpenAPI spec version: 1.0.0
 */
import axios from "axios";
import type { AxiosError, AxiosRequestConfig, AxiosResponse } from "axios";
import useSwr from "swr";
import type { Key, SWRConfiguration } from "swr";
export type GetTokenSearchRep = (typeof GetTokenSearchRep)[keyof typeof GetTokenSearchRep];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetTokenSearchRep = {
  Spam: "Spam",
  Unknown: "Unknown",
  NotFake: "NotFake",
  Reputable: "Reputable",
} as const;

export type GetTokenSearchParams = {
  /**
   * The search query (full or partial token name, ticker, slug, contract address, social handles, or other information)
   */
  q: string;
  /**
   * The maximum number of results to return (default is 5)
   */
  n?: number;
  /**
   * The minimum reputation of the results
   */
  rep?: GetTokenSearchRep;
  /**
   * The account ID of the user. If the user owns or owned a token, it will be slightly boosted in search
   */
  acc?: string;
};

export type GetToken404 = {
  error?: string;
};

export type GetTokenParams = {
  /**
   * The identifier of the token to retrieve information for
   */
  token_id: string;
};

export type GetTokens200 = { [key: string]: TokenDetail };

export type GetHardcodedSuperPrecisePriceParams = {
  token_id: string;
};

export type GetHardcodedPriceParams = {
  token_id: string;
};

export type GetHardcodedGetTokenPrice200 = {
  price?: string;
  token_contract_id?: string;
};

export type GetHardcodedGetTokenPriceParams = {
  token_id: string;
};

export type GetHardcodedSuperPrecise200 = { [key: string]: string };

export type GetHardcodedPrices200 = { [key: string]: number };

export type GetHardcodedListTokenPrice200 = { [key: string]: TokenInfo };

export type GetSuperPrecisePriceParams = {
  token_id: string;
};

export type GetPriceParams = {
  token_id: string;
};

export type GetGetTokenPrice200 = {
  price?: string;
  token_contract_id?: string;
};

export type GetGetTokenPriceParams = {
  token_id: string;
};

export type GetSuperPrecise200 = { [key: string]: string };

export type GetPrices200 = { [key: string]: number };

export type GetListTokenPrice200 = { [key: string]: TokenInfo };

export type TokenDetailSocials = { [key: string]: string };

export type TokenDetailReputation =
  (typeof TokenDetailReputation)[keyof typeof TokenDetailReputation];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TokenDetailReputation = {
  Spam: "Spam",
  Unknown: "Unknown",
  NotFake: "NotFake",
  Reputable: "Reputable",
} as const;

export type TokenDetailMetadata = {
  decimals?: number;
  name?: string;
  symbol?: string;
};

export interface TokenDetail {
  account_id: string;
  circulating_supply: string;
  circulating_supply_excluding_team: string;
  deleted: boolean;
  main_pool: string;
  metadata: TokenDetailMetadata;
  price_usd: string;
  price_usd_hardcoded: string;
  price_usd_raw: string;
  reputation: TokenDetailReputation;
  slug: string[];
  socials: TokenDetailSocials;
  total_supply: string;
}

export interface TokenInfo {
  decimal: number;
  price: string;
  symbol: string;
}

/**
 * Retrieves a list of tokens with their prices, decimals, and symbols
 * @summary List token prices with detailed information
 */
export const getListTokenPrice = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<GetListTokenPrice200>> => {
  return axios.get(`/list-token-price`, options);
};

export const getGetListTokenPriceKey = () => [`/list-token-price`] as const;

export type GetListTokenPriceQueryResult = NonNullable<
  Awaited<ReturnType<typeof getListTokenPrice>>
>;
export type GetListTokenPriceQueryError = AxiosError<unknown>;

/**
 * @summary List token prices with detailed information
 */
export const useGetListTokenPrice = <TError = AxiosError<unknown>>(options?: {
  swr?: SWRConfiguration<Awaited<ReturnType<typeof getListTokenPrice>>, TError> & {
    swrKey?: Key;
    enabled?: boolean;
  };
  axios?: AxiosRequestConfig;
}) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey = swrOptions?.swrKey ?? (() => (isEnabled ? getGetListTokenPriceKey() : null));
  const swrFn = () => getListTokenPrice(axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};

/**
 * Retrieves a list of token prices with standard precision
 * @summary Get token prices
 */
export const getPrices = (options?: AxiosRequestConfig): Promise<AxiosResponse<GetPrices200>> => {
  return axios.get(`/prices`, options);
};

export const getGetPricesKey = () => [`/prices`] as const;

export type GetPricesQueryResult = NonNullable<Awaited<ReturnType<typeof getPrices>>>;
export type GetPricesQueryError = AxiosError<unknown>;

/**
 * @summary Get token prices
 */
export const useGetPrices = <TError = AxiosError<unknown>>(options?: {
  swr?: SWRConfiguration<Awaited<ReturnType<typeof getPrices>>, TError> & {
    swrKey?: Key;
    enabled?: boolean;
  };
  axios?: AxiosRequestConfig;
}) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey = swrOptions?.swrKey ?? (() => (isEnabled ? getGetPricesKey() : null));
  const swrFn = () => getPrices(axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};

/**
 * Retrieves a list of token prices with very high precision
 * @summary Get token prices with high precision
 */
export const getSuperPrecise = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<GetSuperPrecise200>> => {
  return axios.get(`/super-precise`, options);
};

export const getGetSuperPreciseKey = () => [`/super-precise`] as const;

export type GetSuperPreciseQueryResult = NonNullable<Awaited<ReturnType<typeof getSuperPrecise>>>;
export type GetSuperPreciseQueryError = AxiosError<unknown>;

/**
 * @summary Get token prices with high precision
 */
export const useGetSuperPrecise = <TError = AxiosError<unknown>>(options?: {
  swr?: SWRConfiguration<Awaited<ReturnType<typeof getSuperPrecise>>, TError> & {
    swrKey?: Key;
    enabled?: boolean;
  };
  axios?: AxiosRequestConfig;
}) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey = swrOptions?.swrKey ?? (() => (isEnabled ? getGetSuperPreciseKey() : null));
  const swrFn = () => getSuperPrecise(axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};

/**
 * Retrieves the price for a specified token
 * @summary Get price for a specific token
 */
export const getGetTokenPrice = (
  params: GetGetTokenPriceParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<GetGetTokenPrice200>> => {
  return axios.get(`/get-token-price`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getGetGetTokenPriceKey = (params: GetGetTokenPriceParams) =>
  [`/get-token-price`, ...(params ? [params] : [])] as const;

export type GetGetTokenPriceQueryResult = NonNullable<Awaited<ReturnType<typeof getGetTokenPrice>>>;
export type GetGetTokenPriceQueryError = AxiosError<unknown>;

/**
 * @summary Get price for a specific token
 */
export const useGetGetTokenPrice = <TError = AxiosError<unknown>>(
  params: GetGetTokenPriceParams,
  options?: {
    swr?: SWRConfiguration<Awaited<ReturnType<typeof getGetTokenPrice>>, TError> & {
      swrKey?: Key;
      enabled?: boolean;
    };
    axios?: AxiosRequestConfig;
  },
) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey = swrOptions?.swrKey ?? (() => (isEnabled ? getGetGetTokenPriceKey(params) : null));
  const swrFn = () => getGetTokenPrice(params, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};

/**
 * Retrieves the price as a number for a specified token
 * @summary Get price as a number for a specific token
 */
export const getPrice = (
  params: GetPriceParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<number>> => {
  return axios.get(`/price`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getGetPriceKey = (params: GetPriceParams) =>
  [`/price`, ...(params ? [params] : [])] as const;

export type GetPriceQueryResult = NonNullable<Awaited<ReturnType<typeof getPrice>>>;
export type GetPriceQueryError = AxiosError<unknown>;

/**
 * @summary Get price as a number for a specific token
 */
export const useGetPrice = <TError = AxiosError<unknown>>(
  params: GetPriceParams,
  options?: {
    swr?: SWRConfiguration<Awaited<ReturnType<typeof getPrice>>, TError> & {
      swrKey?: Key;
      enabled?: boolean;
    };
    axios?: AxiosRequestConfig;
  },
) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey = swrOptions?.swrKey ?? (() => (isEnabled ? getGetPriceKey(params) : null));
  const swrFn = () => getPrice(params, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};

/**
 * Retrieves the high-precision price as a string for a specified token
 * @summary Get high-precision price as a string for a specific token
 */
export const getSuperPrecisePrice = (
  params: GetSuperPrecisePriceParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<string>> => {
  return axios.get(`/super-precise-price`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getGetSuperPrecisePriceKey = (params: GetSuperPrecisePriceParams) =>
  [`/super-precise-price`, ...(params ? [params] : [])] as const;

export type GetSuperPrecisePriceQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSuperPrecisePrice>>
>;
export type GetSuperPrecisePriceQueryError = AxiosError<unknown>;

/**
 * @summary Get high-precision price as a string for a specific token
 */
export const useGetSuperPrecisePrice = <TError = AxiosError<unknown>>(
  params: GetSuperPrecisePriceParams,
  options?: {
    swr?: SWRConfiguration<Awaited<ReturnType<typeof getSuperPrecisePrice>>, TError> & {
      swrKey?: Key;
      enabled?: boolean;
    };
    axios?: AxiosRequestConfig;
  },
) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey =
    swrOptions?.swrKey ?? (() => (isEnabled ? getGetSuperPrecisePriceKey(params) : null));
  const swrFn = () => getSuperPrecisePrice(params, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};

/**
 * Retrieves a list of tokens with their hardcoded prices, decimals, and symbols. Stablecoins may be rounded to 1 if close to 1.
 * @summary List hardcoded token prices with detailed information
 */
export const getHardcodedListTokenPrice = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<GetHardcodedListTokenPrice200>> => {
  return axios.get(`/hardcoded/list-token-price`, options);
};

export const getGetHardcodedListTokenPriceKey = () => [`/hardcoded/list-token-price`] as const;

export type GetHardcodedListTokenPriceQueryResult = NonNullable<
  Awaited<ReturnType<typeof getHardcodedListTokenPrice>>
>;
export type GetHardcodedListTokenPriceQueryError = AxiosError<unknown>;

/**
 * @summary List hardcoded token prices with detailed information
 */
export const useGetHardcodedListTokenPrice = <TError = AxiosError<unknown>>(options?: {
  swr?: SWRConfiguration<Awaited<ReturnType<typeof getHardcodedListTokenPrice>>, TError> & {
    swrKey?: Key;
    enabled?: boolean;
  };
  axios?: AxiosRequestConfig;
}) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey =
    swrOptions?.swrKey ?? (() => (isEnabled ? getGetHardcodedListTokenPriceKey() : null));
  const swrFn = () => getHardcodedListTokenPrice(axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};

/**
 * Retrieves a list of hardcoded token prices with standard precision. Stablecoins may be rounded to 1 if close to 1.
 * @summary Get hardcoded token prices
 */
export const getHardcodedPrices = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<GetHardcodedPrices200>> => {
  return axios.get(`/hardcoded/prices`, options);
};

export const getGetHardcodedPricesKey = () => [`/hardcoded/prices`] as const;

export type GetHardcodedPricesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getHardcodedPrices>>
>;
export type GetHardcodedPricesQueryError = AxiosError<unknown>;

/**
 * @summary Get hardcoded token prices
 */
export const useGetHardcodedPrices = <TError = AxiosError<unknown>>(options?: {
  swr?: SWRConfiguration<Awaited<ReturnType<typeof getHardcodedPrices>>, TError> & {
    swrKey?: Key;
    enabled?: boolean;
  };
  axios?: AxiosRequestConfig;
}) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey = swrOptions?.swrKey ?? (() => (isEnabled ? getGetHardcodedPricesKey() : null));
  const swrFn = () => getHardcodedPrices(axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};

/**
 * Retrieves a list of hardcoded token prices with very high precision. Stablecoins may be rounded to 1 if close to 1.
 * @summary Get hardcoded token prices with high precision
 */
export const getHardcodedSuperPrecise = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<GetHardcodedSuperPrecise200>> => {
  return axios.get(`/hardcoded/super-precise`, options);
};

export const getGetHardcodedSuperPreciseKey = () => [`/hardcoded/super-precise`] as const;

export type GetHardcodedSuperPreciseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getHardcodedSuperPrecise>>
>;
export type GetHardcodedSuperPreciseQueryError = AxiosError<unknown>;

/**
 * @summary Get hardcoded token prices with high precision
 */
export const useGetHardcodedSuperPrecise = <TError = AxiosError<unknown>>(options?: {
  swr?: SWRConfiguration<Awaited<ReturnType<typeof getHardcodedSuperPrecise>>, TError> & {
    swrKey?: Key;
    enabled?: boolean;
  };
  axios?: AxiosRequestConfig;
}) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey =
    swrOptions?.swrKey ?? (() => (isEnabled ? getGetHardcodedSuperPreciseKey() : null));
  const swrFn = () => getHardcodedSuperPrecise(axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};

/**
 * Retrieves the hardcoded price for a specified token. Stablecoins may be rounded to 1 if close to 1.
 * @summary Get hardcoded price for a specific token
 */
export const getHardcodedGetTokenPrice = (
  params: GetHardcodedGetTokenPriceParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<GetHardcodedGetTokenPrice200>> => {
  return axios.get(`/hardcoded/get-token-price`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getGetHardcodedGetTokenPriceKey = (params: GetHardcodedGetTokenPriceParams) =>
  [`/hardcoded/get-token-price`, ...(params ? [params] : [])] as const;

export type GetHardcodedGetTokenPriceQueryResult = NonNullable<
  Awaited<ReturnType<typeof getHardcodedGetTokenPrice>>
>;
export type GetHardcodedGetTokenPriceQueryError = AxiosError<unknown>;

/**
 * @summary Get hardcoded price for a specific token
 */
export const useGetHardcodedGetTokenPrice = <TError = AxiosError<unknown>>(
  params: GetHardcodedGetTokenPriceParams,
  options?: {
    swr?: SWRConfiguration<Awaited<ReturnType<typeof getHardcodedGetTokenPrice>>, TError> & {
      swrKey?: Key;
      enabled?: boolean;
    };
    axios?: AxiosRequestConfig;
  },
) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey =
    swrOptions?.swrKey ?? (() => (isEnabled ? getGetHardcodedGetTokenPriceKey(params) : null));
  const swrFn = () => getHardcodedGetTokenPrice(params, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};

/**
 * Retrieves the hardcoded price as a number for a specified token. Stablecoins may be rounded to 1 if close to 1.
 * @summary Get hardcoded price as a number for a specific token
 */
export const getHardcodedPrice = (
  params: GetHardcodedPriceParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<number>> => {
  return axios.get(`/hardcoded/price`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getGetHardcodedPriceKey = (params: GetHardcodedPriceParams) =>
  [`/hardcoded/price`, ...(params ? [params] : [])] as const;

export type GetHardcodedPriceQueryResult = NonNullable<
  Awaited<ReturnType<typeof getHardcodedPrice>>
>;
export type GetHardcodedPriceQueryError = AxiosError<unknown>;

/**
 * @summary Get hardcoded price as a number for a specific token
 */
export const useGetHardcodedPrice = <TError = AxiosError<unknown>>(
  params: GetHardcodedPriceParams,
  options?: {
    swr?: SWRConfiguration<Awaited<ReturnType<typeof getHardcodedPrice>>, TError> & {
      swrKey?: Key;
      enabled?: boolean;
    };
    axios?: AxiosRequestConfig;
  },
) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey = swrOptions?.swrKey ?? (() => (isEnabled ? getGetHardcodedPriceKey(params) : null));
  const swrFn = () => getHardcodedPrice(params, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};

/**
 * Retrieves the hardcoded high-precision price as a string for a specified token. Stablecoins may be rounded to 1 if close to 1.
 * @summary Get hardcoded high-precision price as a string for a specific token
 */
export const getHardcodedSuperPrecisePrice = (
  params: GetHardcodedSuperPrecisePriceParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<string>> => {
  return axios.get(`/hardcoded/super-precise-price`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getGetHardcodedSuperPrecisePriceKey = (params: GetHardcodedSuperPrecisePriceParams) =>
  [`/hardcoded/super-precise-price`, ...(params ? [params] : [])] as const;

export type GetHardcodedSuperPrecisePriceQueryResult = NonNullable<
  Awaited<ReturnType<typeof getHardcodedSuperPrecisePrice>>
>;
export type GetHardcodedSuperPrecisePriceQueryError = AxiosError<unknown>;

/**
 * @summary Get hardcoded high-precision price as a string for a specific token
 */
export const useGetHardcodedSuperPrecisePrice = <TError = AxiosError<unknown>>(
  params: GetHardcodedSuperPrecisePriceParams,
  options?: {
    swr?: SWRConfiguration<Awaited<ReturnType<typeof getHardcodedSuperPrecisePrice>>, TError> & {
      swrKey?: Key;
      enabled?: boolean;
    };
    axios?: AxiosRequestConfig;
  },
) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey =
    swrOptions?.swrKey ?? (() => (isEnabled ? getGetHardcodedSuperPrecisePriceKey(params) : null));
  const swrFn = () => getHardcodedSuperPrecisePrice(params, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};

/**
 * Retrieves detailed information for all tokens, including prices, metadata, and supply information
 * @summary Get detailed information for all tokens
 */
export const getTokens = (options?: AxiosRequestConfig): Promise<AxiosResponse<GetTokens200>> => {
  return axios.get(`/tokens`, options);
};

export const getGetTokensKey = () => [`/tokens`] as const;

export type GetTokensQueryResult = NonNullable<Awaited<ReturnType<typeof getTokens>>>;
export type GetTokensQueryError = AxiosError<unknown>;

/**
 * @summary Get detailed information for all tokens
 */
export const useGetTokens = <TError = AxiosError<unknown>>(options?: {
  swr?: SWRConfiguration<Awaited<ReturnType<typeof getTokens>>, TError> & {
    swrKey?: Key;
    enabled?: boolean;
  };
  axios?: AxiosRequestConfig;
}) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey = swrOptions?.swrKey ?? (() => (isEnabled ? getGetTokensKey() : null));
  const swrFn = () => getTokens(axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};

/**
 * Retrieves detailed information for a specific token, including prices, metadata, and supply information
 * @summary Get detailed information for a specific token
 */
export const getToken = (
  params: GetTokenParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<TokenDetail>> => {
  return axios.get(`/token`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getGetTokenKey = (params: GetTokenParams) =>
  [`/token`, ...(params ? [params] : [])] as const;

export type GetTokenQueryResult = NonNullable<Awaited<ReturnType<typeof getToken>>>;
export type GetTokenQueryError = AxiosError<GetToken404>;

/**
 * @summary Get detailed information for a specific token
 */
export const useGetToken = <TError = AxiosError<GetToken404>>(
  params: GetTokenParams,
  options?: {
    swr?: SWRConfiguration<Awaited<ReturnType<typeof getToken>>, TError> & {
      swrKey?: Key;
      enabled?: boolean;
    };
    axios?: AxiosRequestConfig;
  },
) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey = swrOptions?.swrKey ?? (() => (isEnabled ? getGetTokenKey(params) : null));
  const swrFn = () => getToken(params, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};

/**
 * Search for tokens based on various criteria including name, ticker, slug, contract address, or social handles
 * @summary Search for tokens
 */
export const getTokenSearch = (
  params: GetTokenSearchParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<TokenDetail[]>> => {
  return axios.get(`/token-search`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getGetTokenSearchKey = (params: GetTokenSearchParams) =>
  [`/token-search`, ...(params ? [params] : [])] as const;

export type GetTokenSearchQueryResult = NonNullable<Awaited<ReturnType<typeof getTokenSearch>>>;
export type GetTokenSearchQueryError = AxiosError<unknown>;

/**
 * @summary Search for tokens
 */
export const useGetTokenSearch = <TError = AxiosError<unknown>>(
  params: GetTokenSearchParams,
  options?: {
    swr?: SWRConfiguration<Awaited<ReturnType<typeof getTokenSearch>>, TError> & {
      swrKey?: Key;
      enabled?: boolean;
    };
    axios?: AxiosRequestConfig;
  },
) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey = swrOptions?.swrKey ?? (() => (isEnabled ? getGetTokenSearchKey(params) : null));
  const swrFn = () => getTokenSearch(params, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};

/**
 * Retrieves a list of token IDs for all tokens marked as spam
 * @summary Get list of spam tokens
 */
export const getTokenSpamList = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<string[]>> => {
  return axios.get(`/token-spam-list`, options);
};

export const getGetTokenSpamListKey = () => [`/token-spam-list`] as const;

export type GetTokenSpamListQueryResult = NonNullable<Awaited<ReturnType<typeof getTokenSpamList>>>;
export type GetTokenSpamListQueryError = AxiosError<unknown>;

/**
 * @summary Get list of spam tokens
 */
export const useGetTokenSpamList = <TError = AxiosError<unknown>>(options?: {
  swr?: SWRConfiguration<Awaited<ReturnType<typeof getTokenSpamList>>, TError> & {
    swrKey?: Key;
    enabled?: boolean;
  };
  axios?: AxiosRequestConfig;
}) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey = swrOptions?.swrKey ?? (() => (isEnabled ? getGetTokenSpamListKey() : null));
  const swrFn = () => getTokenSpamList(axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};

/**
 * Retrieves a list of token IDs for all tokens with a reputation of Unknown, NotFake, or Reputable
 * @summary Get list of tokens with Unknown or better reputation
 */
export const getTokenUnknownOrBetterList = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<string[]>> => {
  return axios.get(`/token-unknown-or-better-list`, options);
};

export const getGetTokenUnknownOrBetterListKey = () => [`/token-unknown-or-better-list`] as const;

export type GetTokenUnknownOrBetterListQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTokenUnknownOrBetterList>>
>;
export type GetTokenUnknownOrBetterListQueryError = AxiosError<unknown>;

/**
 * @summary Get list of tokens with Unknown or better reputation
 */
export const useGetTokenUnknownOrBetterList = <TError = AxiosError<unknown>>(options?: {
  swr?: SWRConfiguration<Awaited<ReturnType<typeof getTokenUnknownOrBetterList>>, TError> & {
    swrKey?: Key;
    enabled?: boolean;
  };
  axios?: AxiosRequestConfig;
}) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey =
    swrOptions?.swrKey ?? (() => (isEnabled ? getGetTokenUnknownOrBetterListKey() : null));
  const swrFn = () => getTokenUnknownOrBetterList(axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};

/**
 * Retrieves a list of token IDs for all tokens with a reputation of NotFake or Reputable
 * @summary Get list of tokens with NotFake or better reputation
 */
export const getTokenNotfakeOrBetterList = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<string[]>> => {
  return axios.get(`/token-notfake-or-better-list`, options);
};

export const getGetTokenNotfakeOrBetterListKey = () => [`/token-notfake-or-better-list`] as const;

export type GetTokenNotfakeOrBetterListQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTokenNotfakeOrBetterList>>
>;
export type GetTokenNotfakeOrBetterListQueryError = AxiosError<unknown>;

/**
 * @summary Get list of tokens with NotFake or better reputation
 */
export const useGetTokenNotfakeOrBetterList = <TError = AxiosError<unknown>>(options?: {
  swr?: SWRConfiguration<Awaited<ReturnType<typeof getTokenNotfakeOrBetterList>>, TError> & {
    swrKey?: Key;
    enabled?: boolean;
  };
  axios?: AxiosRequestConfig;
}) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey =
    swrOptions?.swrKey ?? (() => (isEnabled ? getGetTokenNotfakeOrBetterListKey() : null));
  const swrFn = () => getTokenNotfakeOrBetterList(axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};

/**
 * Retrieves a list of token IDs for all tokens with a Reputable reputation
 * @summary Get list of reputable tokens
 */
export const getReputableList = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<string[]>> => {
  return axios.get(`/reputable-list`, options);
};

export const getGetReputableListKey = () => [`/reputable-list`] as const;

export type GetReputableListQueryResult = NonNullable<Awaited<ReturnType<typeof getReputableList>>>;
export type GetReputableListQueryError = AxiosError<unknown>;

/**
 * @summary Get list of reputable tokens
 */
export const useGetReputableList = <TError = AxiosError<unknown>>(options?: {
  swr?: SWRConfiguration<Awaited<ReturnType<typeof getReputableList>>, TError> & {
    swrKey?: Key;
    enabled?: boolean;
  };
  axios?: AxiosRequestConfig;
}) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey = swrOptions?.swrKey ?? (() => (isEnabled ? getGetReputableListKey() : null));
  const swrFn = () => getReputableList(axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};

/**
 * Retrieves detailed information for all tokens with a reputation of Unknown, NotFake, or Reputable
 * @summary Get detailed information for tokens with Unknown or better reputation
 */
export const getTokensUnknownOrBetter = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<TokenDetail[]>> => {
  return axios.get(`/tokens-unknown-or-better`, options);
};

export const getGetTokensUnknownOrBetterKey = () => [`/tokens-unknown-or-better`] as const;

export type GetTokensUnknownOrBetterQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTokensUnknownOrBetter>>
>;
export type GetTokensUnknownOrBetterQueryError = AxiosError<unknown>;

/**
 * @summary Get detailed information for tokens with Unknown or better reputation
 */
export const useGetTokensUnknownOrBetter = <TError = AxiosError<unknown>>(options?: {
  swr?: SWRConfiguration<Awaited<ReturnType<typeof getTokensUnknownOrBetter>>, TError> & {
    swrKey?: Key;
    enabled?: boolean;
  };
  axios?: AxiosRequestConfig;
}) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey =
    swrOptions?.swrKey ?? (() => (isEnabled ? getGetTokensUnknownOrBetterKey() : null));
  const swrFn = () => getTokensUnknownOrBetter(axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};

/**
 * Retrieves detailed information for all tokens with a reputation of NotFake or Reputable
 * @summary Get detailed information for tokens with NotFake or better reputation
 */
export const getTokensNotfakeOrBetter = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<TokenDetail[]>> => {
  return axios.get(`/tokens-notfake-or-better`, options);
};

export const getGetTokensNotfakeOrBetterKey = () => [`/tokens-notfake-or-better`] as const;

export type GetTokensNotfakeOrBetterQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTokensNotfakeOrBetter>>
>;
export type GetTokensNotfakeOrBetterQueryError = AxiosError<unknown>;

/**
 * @summary Get detailed information for tokens with NotFake or better reputation
 */
export const useGetTokensNotfakeOrBetter = <TError = AxiosError<unknown>>(options?: {
  swr?: SWRConfiguration<Awaited<ReturnType<typeof getTokensNotfakeOrBetter>>, TError> & {
    swrKey?: Key;
    enabled?: boolean;
  };
  axios?: AxiosRequestConfig;
}) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey =
    swrOptions?.swrKey ?? (() => (isEnabled ? getGetTokensNotfakeOrBetterKey() : null));
  const swrFn = () => getTokensNotfakeOrBetter(axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};

/**
 * Retrieves detailed information for all tokens with a Reputable reputation
 * @summary Get detailed information for reputable tokens
 */
export const getTokensReputable = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<TokenDetail[]>> => {
  return axios.get(`/tokens-reputable`, options);
};

export const getGetTokensReputableKey = () => [`/tokens-reputable`] as const;

export type GetTokensReputableQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTokensReputable>>
>;
export type GetTokensReputableQueryError = AxiosError<unknown>;

/**
 * @summary Get detailed information for reputable tokens
 */
export const useGetTokensReputable = <TError = AxiosError<unknown>>(options?: {
  swr?: SWRConfiguration<Awaited<ReturnType<typeof getTokensReputable>>, TError> & {
    swrKey?: Key;
    enabled?: boolean;
  };
  axios?: AxiosRequestConfig;
}) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey = swrOptions?.swrKey ?? (() => (isEnabled ? getGetTokensReputableKey() : null));
  const swrFn = () => getTokensReputable(axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};
