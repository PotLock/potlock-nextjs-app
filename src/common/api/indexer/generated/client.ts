/**
 * Generated by orval v6.31.0 üç∫
 * Do not edit manually.
 * PotLock Indexer API testnet
 * Indexed data for the PotLock protocol
 * OpenAPI spec version: 1.0.0
 */
import axios from "axios";
import type { AxiosError, AxiosRequestConfig, AxiosResponse } from "axios";
import useSwr from "swr";
import type { Key, SWRConfiguration } from "swr";
export type V1RoundsApplicationsRetrieveParams = {
  /**
   * Page number for pagination
   */
  page?: number;
  /**
   * Number of results per page
   */
  page_size?: number;
};

export type V1RoundsRetrieveParams = {
  /**
   * Filter projects by chain
   */
  chain?: string;
  /**
   * Page number for pagination
   */
  page?: number;
  /**
   * Number of results per page
   */
  page_size?: number;
  /**
   * Sort by field, e.g., deployed_at, vault_total_deposits
   */
  sort?: string;
};

export type V1RoundVotesRetrieveParams = {
  /**
   * Page number for pagination
   */
  page?: number;
  /**
   * Number of results per page
   */
  page_size?: number;
};

export type V1ProjectsRetrieveParams = {
  /**
   * Filter projects by owner id
   */
  owner?: string;
  /**
   * Page number for pagination
   */
  page?: number;
  /**
   * Number of results per page
   */
  page_size?: number;
  /**
   * Filter projects by status
   */
  status?: string;
};

export type V1PotsSponsorsRetrieveParams = {
  /**
   * Page number for pagination
   */
  page?: number;
  /**
   * Number of results per page
   */
  page_size?: number;
};

export type V1PotsPayoutsRetrieveParams = {
  /**
   * Page number for pagination
   */
  page?: number;
  /**
   * Number of results per page
   */
  page_size?: number;
};

export type V1PotsDonationsRetrieveParams = {
  /**
   * Page number for pagination
   */
  page?: number;
  /**
   * Number of results per page
   */
  page_size?: number;
};

export type V1PotsApplicationsRetrieveParams = {
  /**
   * Page number for pagination
   */
  page?: number;
  /**
   * Number of results per page
   */
  page_size?: number;
  /**
   * Filter by application status
   */
  status?: string;
};

export type V1PotsRetrieveParams = {
  /**
   * Page number for pagination
   */
  page?: number;
  /**
   * Number of results per page
   */
  page_size?: number;
};

export type V1PotfactoriesRetrieveParams = {
  /**
   * Page number for pagination
   */
  page?: number;
  /**
   * Number of results per page
   */
  page_size?: number;
};

export type V1ListsRegistrationsRetrieveParams = {
  /**
   * Filter registrations by category
   */
  category?: string;
  /**
   * Page number for pagination
   */
  page?: number;
  /**
   * Number of results per page
   */
  page_size?: number;
  /**
   * Filter registrations by status
   */
  status?: string;
};

export type V1ListsRandomRegistrationRetrieveParams = {
  /**
   * Filter registrations by status
   */
  status?: string;
};

export type V1ListsRetrieveParams = {
  /**
   * Filter lists by account
   */
  account?: string;
  /**
   * Page number for pagination
   */
  page?: number;
  /**
   * Number of results per page
   */
  page_size?: number;
};

export type V1DonorsRetrieveParams = {
  /**
   * Page number for pagination
   */
  page?: number;
  /**
   * Number of results per page
   */
  page_size?: number;
  /**
   * Sort by field, e.g., most_donated_usd
   */
  sort?: string;
};

export type V1DonateContractConfigRetrieveParams = {
  /**
   * Page number for pagination
   */
  page?: number;
  /**
   * Number of results per page
   */
  page_size?: number;
};

export type V1AccountsUpvotedListsRetrieveParams = {
  /**
   * Page number for pagination
   */
  page?: number;
  /**
   * Number of results per page
   */
  page_size?: number;
};

export type V1AccountsPotApplicationsRetrieveParams = {
  /**
   * Page number for pagination
   */
  page?: number;
  /**
   * Number of results per page
   */
  page_size?: number;
  /**
   * Filter pot applications by status
   */
  status?: string;
};

export type V1AccountsPayoutsReceivedRetrieveParams = {
  /**
   * Page number for pagination
   */
  page?: number;
  /**
   * Number of results per page
   */
  page_size?: number;
};

export type V1AccountsListRegistrationsRetrieveParams = {
  /**
   * Page number for pagination
   */
  page?: number;
  /**
   * Number of results per page
   */
  page_size?: number;
};

export type V1AccountsDonationsSentRetrieveParams = {
  /**
   * Page number for pagination
   */
  page?: number;
  /**
   * Number of results per page
   */
  page_size?: number;
};

export type V1AccountsDonationsReceivedRetrieveParams = {
  /**
   * Page number for pagination
   */
  page?: number;
  /**
   * Number of results per page
   */
  page_size?: number;
};

export type V1AccountsActivePotsRetrieveParams = {
  /**
   * Page number for pagination
   */
  page?: number;
  /**
   * Number of results per page
   */
  page_size?: number;
  /**
   * Filter by pot status
   */
  status?: string;
};

export type V1AccountsRetrieveParams = {
  /**
   * Page number for pagination
   */
  page?: number;
  /**
   * Number of results per page
   */
  page_size?: number;
};

export type V1ProjectsRetrieve2Params = {
  /**
   * Page number for pagination
   */
  page?: number;
  /**
   * Number of results per page
   */
  page_size?: number;
};

export type V1ProjectStatsRetrieveParams = {
  /**
   * Page number for pagination
   */
  page?: number;
  /**
   * Number of results per page
   */
  page_size?: number;
};

export interface VotePair {
  /**
   * @minimum 0
   * @maximum 2147483647
   */
  pair_id: number;
  project: Project;
}

export interface Vote {
  readonly id: number;
  pairs: VotePair[];
  /** Round ID in DB (does not necessarily correspond to on-chain ID). */
  round: number;
  /**
   * Transaction hash.
   * @nullable
   */
  tx_hash?: string | null;
  voted_at: string;
  voter: Account;
}

export interface Token {
  /** Token ID (address). */
  account: string;
  /**
   * Token id on coingecko.
   * @maxLength 255
   * @nullable
   */
  coingecko_id?: string | null;
  /**
   * Token decimals.
   * @minimum 0
   * @maximum 2147483647
   */
  decimals: number;
  /**
   * Token icon (base64 data URL).
   * @nullable
   */
  icon?: string | null;
  /**
   * Token name.
   * @maxLength 255
   * @nullable
   */
  name?: string | null;
  /**
   * Token symbol.
   * @maxLength 255
   * @nullable
   */
  symbol?: string | null;
}

/**
 * * `Pending` - Pending
 * `Approved` - Approved
 * `Rejected` - Rejected
 * `Graylisted` - Graylisted
 * `Blacklisted` - Blacklisted
 */
export type StatusF24Enum = (typeof StatusF24Enum)[keyof typeof StatusF24Enum];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const StatusF24Enum = {
  Pending: "Pending",
  Approved: "Approved",
  Rejected: "Rejected",
  Graylisted: "Graylisted",
  Blacklisted: "Blacklisted",
} as const;

/**
 * * `Pending` - Pending
 * `Approved` - Approved
 * `Rejected` - Rejected
 * `InReview` - InReview
 * `Blacklisted` - Blacklisted
 */
export type Status68eEnum = (typeof Status68eEnum)[keyof typeof Status68eEnum];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Status68eEnum = {
  Pending: "Pending",
  Approved: "Approved",
  Rejected: "Rejected",
  InReview: "InReview",
  Blacklisted: "Blacklisted",
} as const;

export interface StatsResponse {
  total_donations_count: number;
  total_donations_usd: number;
  total_donors_count: number;
  total_payouts_usd: number;
  total_recipients_count: number;
}

/**
 * * `NEW` - New
 * `APPROVED` - Approved
 * `REJECTED` - Rejected
 * `COMPLETED` - Completed
 */
export type ProjectStatusEnum =
  (typeof ProjectStatusEnum)[keyof typeof ProjectStatusEnum];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ProjectStatusEnum = {
  NEW: "NEW",
  APPROVED: "APPROVED",
  REJECTED: "REJECTED",
  COMPLETED: "COMPLETED",
} as const;

export interface ProjectRepository {
  readonly id: number;
  /** @maxLength 255 */
  label: string;
  /** @maxLength 200 */
  url: string;
}

export interface ProjectContract {
  /** @maxLength 255 */
  contract_address: string;
  readonly id: number;
  /** @maxLength 255 */
  name: string;
}

export interface ProjectContact {
  readonly id: number;
  /** @maxLength 255 */
  name: string;
  /** @maxLength 255 */
  value: string;
}

export interface Project {
  /** Project Admin */
  admins: string[];
  contacts?: ProjectContact[];
  contracts?: ProjectContract[];
  readonly id: number;
  /** @maxLength 200 */
  image_url: string;
  /** @maxLength 255 */
  name: string;
  /**
   * Project id in contract
   * @minimum -2147483648
   * @maximum 2147483647
   */
  on_chain_id: number;
  overview: string;
  owner: Account;
  payout_address: Account;
  repositories?: ProjectRepository[];
  status: ProjectStatusEnum;
  /**
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   */
  submited_ms: number;
  /** Project Team Member */
  team_members: string[];
  /**
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   * @nullable
   */
  updated_ms?: number | null;
  /** @maxLength 200 */
  video_url: string;
}

export interface PotPayout {
  /** Payout amount. */
  amount: string;
  /**
   * Payout amount in USD.
   * @nullable
   * @pattern ^-?\d{0,18}(?:\.\d{0,2})?$
   */
  amount_paid_usd?: string | null;
  /** Payout id. */
  readonly id: number;
  /**
   * Payout date.
   * @nullable
   */
  paid_at?: string | null;
  pot: Pot;
  recipient: Account;
  token: Token;
  /**
   * Transaction hash.
   * @nullable
   */
  tx_hash?: string | null;
}

/**
 * Pot factory source metadata.
 * @nullable
 */
export type PotFactorySourceMetadata = unknown | null;

export interface PotFactory {
  /** Pot factory account ID. */
  account: string;
  admins: Account[];
  /** Pot factory deployment date. */
  deployed_at: string;
  owner: Account;
  /**
   * Pot factory protocol fee basis points.
   * @minimum 0
   * @maximum 2147483647
   */
  protocol_fee_basis_points: number;
  protocol_fee_recipient: Account;
  /** Require whitelist. */
  require_whitelist: boolean;
  /**
   * Pot factory source metadata.
   * @nullable
   */
  source_metadata?: PotFactorySourceMetadata;
  whitelisted_deployers: Account[];
}

export interface Pot {
  /** Pot account ID. */
  account: string;
  admins: Account[];
  /** All paid out. */
  all_paid_out: boolean;
  /** Pot application end date. */
  application_end: string;
  /** Pot application start date. */
  application_start: string;
  /**
   * Base currency.
   * @maxLength 64
   * @nullable
   */
  base_currency?: string | null;
  chef: Account;
  /**
   * Chef fee basis points.
   * @minimum 0
   * @maximum 2147483647
   */
  chef_fee_basis_points: number;
  /**
   * Pot cooldown end date.
   * @nullable
   */
  cooldown_end?: string | null;
  /**
   * Pot cooldown period in ms.
   * @minimum 0
   * @maximum 2147483647
   * @nullable
   */
  cooldown_period_ms?: number | null;
  /**
   * Custom min threshold score.
   * @minimum 0
   * @maximum 2147483647
   * @nullable
   */
  custom_min_threshold_score?: number | null;
  /**
   * Custom sybil checks.
   * @nullable
   */
  custom_sybil_checks?: string | null;
  /** Pot deployment date. */
  deployed_at: string;
  deployer: Account;
  /** Pot description. */
  description: string;
  /** Matching pool balance. */
  matching_pool_balance: string;
  /**
   * Matching pool donations count.
   * @minimum 0
   * @maximum 2147483647
   */
  matching_pool_donations_count: number;
  /** Pot matching round end date. */
  matching_round_end: string;
  /** Pot matching round start date. */
  matching_round_start: string;
  /**
   * Max approved applicants.
   * @minimum 0
   * @maximum 2147483647
   */
  max_approved_applicants: number;
  /** Min matching pool donation amount. */
  min_matching_pool_donation_amount: string;
  /** Pot name. */
  name: string;
  owner: Account;
  /** Pot factory. */
  pot_factory: string;
  /**
   * Protocol config provider.
   * @nullable
   */
  protocol_config_provider?: string | null;
  /**
   * Public donations count.
   * @minimum 0
   * @maximum 2147483647
   */
  public_donations_count: number;
  /**
   * Referral fee matching pool basis points.
   * @minimum 0
   * @maximum 2147483647
   */
  referral_fee_matching_pool_basis_points: number;
  /**
   * Referral fee public round basis points.
   * @minimum 0
   * @maximum 2147483647
   */
  referral_fee_public_round_basis_points: number;
  /**
   * Registry provider.
   * @nullable
   */
  registry_provider?: string | null;
  /** Pot source metadata. */
  source_metadata: unknown;
  /**
   * Sybil wrapper provider.
   * @nullable
   */
  sybil_wrapper_provider?: string | null;
  /** Total matching pool. */
  total_matching_pool: string;
  /** @pattern ^-?\d{0,18}(?:\.\d{0,2})?$ */
  total_matching_pool_usd: string;
  /** Total public donations. */
  total_public_donations: string;
  /** @pattern ^-?\d{0,18}(?:\.\d{0,2})?$ */
  total_public_donations_usd: string;
}

export interface PotApplication {
  applicant: Account;
  /** Application id. */
  readonly id: number;
  /**
   * Application message.
   * @maxLength 1024
   * @nullable
   */
  message?: string | null;
  pot: Pot;
  /** Application status.

* `Pending` - Pending
* `Approved` - Approved
* `Rejected` - Rejected
* `InReview` - InReview
* `Blacklisted` - Blacklisted */
  status: Status68eEnum;
  /** Application submission date. */
  submitted_at: string;
  /**
   * Transaction hash.
   * @nullable
   */
  tx_hash?: string | null;
  /**
   * Application last update date.
   * @nullable
   */
  updated_at?: string | null;
}

export interface PaginatedVotesResponse {
  count: number;
  /** @nullable */
  next: string | null;
  /** @nullable */
  previous: string | null;
  results: Vote[];
}

export interface PaginatedRoundsResponse {
  count: number;
  /** @nullable */
  next: string | null;
  /** @nullable */
  previous: string | null;
  results: Round[];
}

export interface PaginatedRoundApplicationsResponse {
  count: number;
  /** @nullable */
  next: string | null;
  /** @nullable */
  previous: string | null;
  results: RoundApplication[];
}

export interface PaginatedProjectsResponse {
  count: number;
  /** @nullable */
  next: string | null;
  /** @nullable */
  previous: string | null;
  results: Project[];
}

export interface PaginatedPotsResponse {
  count: number;
  /** @nullable */
  next: string | null;
  /** @nullable */
  previous: string | null;
  results: Pot[];
}

export interface PaginatedPotPayoutsResponse {
  count: number;
  /** @nullable */
  next: string | null;
  /** @nullable */
  previous: string | null;
  results: PotPayout[];
}

export interface PaginatedPotFactoriesResponse {
  count: number;
  /** @nullable */
  next: string | null;
  /** @nullable */
  previous: string | null;
  results: PotFactory[];
}

export interface PaginatedPotApplicationsResponse {
  count: number;
  /** @nullable */
  next: string | null;
  /** @nullable */
  previous: string | null;
  results: PotApplication[];
}

export interface PaginatedListsResponse {
  count: number;
  /** @nullable */
  next: string | null;
  /** @nullable */
  previous: string | null;
  results: List[];
}

export interface PaginatedListRegistrationsResponse {
  count: number;
  /** @nullable */
  next: string | null;
  /** @nullable */
  previous: string | null;
  results: ListRegistration[];
}

export interface PaginatedDonationsResponse {
  count: number;
  /** @nullable */
  next: string | null;
  /** @nullable */
  previous: string | null;
  results: Donation[];
}

export interface PaginatedAccountsResponse {
  count: number;
  /** @nullable */
  next: string | null;
  /** @nullable */
  previous: string | null;
  results: Account[];
}

export interface Nft {
  baseUri?: string;
  contractId?: string;
  media?: string;
  tokenId?: string;
}

export interface ListUpvote {
  /** Account that upvoted the list. */
  account: string;
  /** Upvote creation date. */
  created_at: string;
  /** Upvote id. */
  readonly id: number;
  /** List upvoted. */
  list: number;
}

export interface Linktree {
  github?: string;
  telegram?: string;
  twitter?: string;
  website?: string;
}

export interface Image {
  ipfs_cid?: string;
  nft?: Nft;
  url?: string;
}

export interface NearSocialProfileData {
  backgroundImage?: Image;
  description?: string;
  image?: Image;
  linktree?: Linktree;
  name?: string;
  /** JSON-stringified array of category strings */
  plCategories?: string;
  /** JSON-stringified array of funding source objects */
  plFundingSources?: string;
  /** JSON-stringified array of URLs */
  plGithubRepos?: string;
  plPublicGoodReason?: string;
  /** JSON-stringified object with chain names as keys that map to nested objects of contract addresses */
  plSmartContracts?: string;
  /** JSON-stringified array of team member account ID strings */
  plTeam?: string;
}

export interface DonationContractConfig {
  owner: string;
  protocol_fee_basis_points: number;
  protocol_fee_recipient_account: string;
  referral_fee_basis_points: number;
}

/**
 * * `Pending` - Pending
 * `Approved` - Approved
 * `Rejected` - Rejected
 * `Graylisted` - Graylisted
 * `Blacklisted` - Blacklisted
 */
export type DefaultRegistrationStatusEnum =
  (typeof DefaultRegistrationStatusEnum)[keyof typeof DefaultRegistrationStatusEnum];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DefaultRegistrationStatusEnum = {
  Pending: "Pending",
  Approved: "Approved",
  Rejected: "Rejected",
  Graylisted: "Graylisted",
  Blacklisted: "Blacklisted",
} as const;

export interface Account {
  donors_count: number;
  /**
   * On-chain account address.
   * @maxLength 64
   */
  id: string;
  near_social_profile_data?: NearSocialProfileData;
  /**
   * @minimum -1000000000000000000
   * @maximum 1000000000000000000
   * @exclusiveMinimum
   * @exclusiveMaximum
   */
  total_donations_in_usd: number;
  /**
   * @minimum -1000000000000000000
   * @maximum 1000000000000000000
   * @exclusiveMinimum
   * @exclusiveMaximum
   */
  total_donations_out_usd: number;
  /**
   * @minimum -1000000000000000000
   * @maximum 1000000000000000000
   * @exclusiveMinimum
   * @exclusiveMaximum
   */
  total_matching_pool_allocations_usd: number;
}

export interface Round {
  admins: Account[];
  /** Allow applications. */
  allow_applications: boolean;
  /** Allow remaining dist. */
  allow_remaining_dist: boolean;
  /**
   * Round application end date.
   * @nullable
   */
  application_end?: string | null;
  /**
   * Round application start date.
   * @nullable
   */
  application_start?: string | null;
  /** Projects Approved for round. */
  approved_projects: string[];
  /**
   * Base currency.
   * @maxLength 64
   * @nullable
   */
  base_currency?: string | null;
  /**
   * Compliance end date.
   * @nullable
   */
  compliance_end?: string | null;
  /**
   * Compliance period in ms.
   * @minimum 0
   * @maximum 2147483647
   * @nullable
   */
  compliance_period_ms?: number | null;
  /** Compliance req desc. */
  compliance_req_desc: string;
  contacts?: ProjectContact[];
  /**
   * Round cooldown end date.
   * @nullable
   */
  cooldown_end?: string | null;
  /**
   * Round cooldown period in ms.
   * @minimum 0
   * @maximum 2147483647
   * @nullable
   */
  cooldown_period_ms?: number | null;
  /**
   * Current vault balance.
   * @maxLength 255
   * @nullable
   */
  current_vault_balance?: string | null;
  /** @pattern ^-?\d{0,18}(?:\.\d{0,2})?$ */
  current_vault_balance_usd: string;
  /** Round deployment date. */
  deployed_at: string;
  /** Round description. */
  description: string;
  /** Expected amount. */
  expected_amount: string;
  /** Round factory account ID. */
  factory_contract: string;
  /** Round ID in DB (does not necessarily correspond to on-chain ID). */
  readonly id: number;
  /** Is video required. */
  is_video_required: boolean;
  /**
   * Max participants.
   * @minimum 0
   * @maximum 2147483647
   * @nullable
   */
  max_participants?: number | null;
  /** Round name. */
  name: string;
  /**
   * Number of picks per voter.
   * @minimum 0
   * @maximum 2147483647
   * @nullable
   */
  num_picks_per_voter?: number | null;
  /**
   * Round ID in contract
   * @minimum -2147483648
   * @maximum 2147483647
   */
  on_chain_id: number;
  owner: Account;
  /**
   * Referrer fee basis points.
   * @minimum 0
   * @maximum 2147483647
   * @nullable
   */
  referrer_fee_basis_points?: number | null;
  remaining_dist_address: Account;
  /**
   * Remaining dist at ms.
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   * @nullable
   */
  remaining_dist_at_ms?: number | null;
  remaining_dist_by: Account;
  /**
   * Remaining dist memo.
   * @maxLength 255
   * @nullable
   */
  remaining_dist_memo?: string | null;
  /**
   * Round complete date.
   * @nullable
   */
  round_complete?: string | null;
  /** Use vault. */
  use_vault: boolean;
  /** Use whitelist. */
  use_whitelist: boolean;
  /**
   * Vault total deposits.
   * @nullable
   */
  vault_total_deposits?: string | null;
  /** @pattern ^-?\d{0,18}(?:\.\d{0,2})?$ */
  vault_total_deposits_usd: string;
  /** Round voting end date. */
  voting_end: string;
  /** Round voting start date. */
  voting_start: string;
}

export interface List {
  /** Admin only registrations. */
  admin_only_registrations: boolean;
  admins: Account[];
  /**
   * Cover image url.
   * @maxLength 200
   * @nullable
   */
  cover_image_url?: string | null;
  /** List creation date. */
  created_at: string;
  /** Default registration status.

* `Pending` - Pending
* `Approved` - Approved
* `Rejected` - Rejected
* `Graylisted` - Graylisted
* `Blacklisted` - Blacklisted */
  default_registration_status: DefaultRegistrationStatusEnum;
  /**
   * List description.
   * @maxLength 256
   * @nullable
   */
  description?: string | null;
  /** List ID in DB (does not necessarily correspond to on-chain ID). */
  readonly id: number;
  /**
   * List name.
   * @maxLength 64
   */
  name: string;
  /**
   * List ID in contract
   * @minimum -2147483648
   * @maximum 2147483647
   */
  on_chain_id: number;
  owner: Account;
  readonly registrations_count: string;
  /** List last update date. */
  updated_at: string;
  upvotes: ListUpvote[];
}

export interface ListRegistration {
  /**
   * Admin notes.
   * @maxLength 1024
   * @nullable
   */
  admin_notes?: string | null;
  /** Registration id. */
  readonly id: number;
  list: List;
  registered_by: Account;
  registrant: Account;
  /**
   * Registrant notes.
   * @maxLength 1024
   * @nullable
   */
  registrant_notes?: string | null;
  /** Registration status.

* `Pending` - Pending
* `Approved` - Approved
* `Rejected` - Rejected
* `Graylisted` - Graylisted
* `Blacklisted` - Blacklisted */
  status: StatusF24Enum;
  /** Registration submission date. */
  submitted_at: string;
  /**
   * Transaction hash.
   * @maxLength 64
   * @nullable
   */
  tx_hash?: string | null;
  /** Registration last update date. */
  updated_at: string;
}

export interface Donation {
  chef: Account;
  /**
   * Chef fee.
   * @maxLength 64
   * @nullable
   */
  chef_fee?: string | null;
  /**
   * Chef fee in USD.
   * @nullable
   * @pattern ^-?\d{0,18}(?:\.\d{0,2})?$
   */
  chef_fee_usd?: string | null;
  /** Donation date. */
  donated_at: string;
  donor: Account;
  /** Donation id. */
  readonly id: number;
  /** Matching pool. */
  matching_pool: boolean;
  /**
   * Donation message.
   * @maxLength 1024
   * @nullable
   */
  message?: string | null;
  /**
   * Net amount.
   * @maxLength 64
   */
  net_amount: string;
  /**
   * Net amount in USD.
   * @nullable
   * @pattern ^-?\d{0,18}(?:\.\d{0,2})?$
   */
  net_amount_usd?: string | null;
  /**
   * Donation id in contract
   * @minimum -2147483648
   * @maximum 2147483647
   */
  on_chain_id: number;
  pot: Pot;
  /**
   * Protocol fee.
   * @maxLength 64
   */
  protocol_fee: string;
  /**
   * Protocol fee in USD.
   * @nullable
   * @pattern ^-?\d{0,18}(?:\.\d{0,2})?$
   */
  protocol_fee_usd?: string | null;
  recipient: Account;
  referrer: Account;
  /**
   * Referrer fee.
   * @maxLength 64
   * @nullable
   */
  referrer_fee?: string | null;
  /**
   * Referrer fee in USD.
   * @nullable
   * @pattern ^-?\d{0,18}(?:\.\d{0,2})?$
   */
  referrer_fee_usd?: string | null;
  token: Token;
  /**
   * Total amount.
   * @maxLength 64
   */
  total_amount: string;
  /**
   * Total amount in USD.
   * @nullable
   * @pattern ^-?\d{0,18}(?:\.\d{0,2})?$
   */
  total_amount_usd?: string | null;
  /**
   * Transaction hash.
   * @maxLength 64
   * @nullable
   */
  tx_hash?: string | null;
}

export interface ApplicationReview {
  /**
   * Review notes.
   * @maxLength 1024
   * @nullable
   */
  notes?: string | null;
  /** Review date. */
  reviewed_at: string;
  reviewer: Account;
  /** Application status for this review.

* `Pending` - Pending
* `Approved` - Approved
* `Rejected` - Rejected
* `InReview` - InReview
* `Blacklisted` - Blacklisted */
  status: Status68eEnum;
  /**
   * Transaction hash.
   * @nullable
   */
  tx_hash?: string | null;
}

export interface RoundApplication {
  applicant: Account;
  /** Application id. */
  readonly id: number;
  /**
   * Application message.
   * @maxLength 1024
   * @nullable
   */
  message?: string | null;
  project: Account;
  reviews: ApplicationReview[];
  round: Round;
  /** Application status.

* `Pending` - Pending
* `Approved` - Approved
* `Rejected` - Rejected
* `InReview` - InReview
* `Blacklisted` - Blacklisted */
  status: Status68eEnum;
  /** Application submission date. */
  submitted_at: string;
  /**
   * Transaction hash.
   * @nullable
   */
  tx_hash?: string | null;
  /**
   * Application last update date.
   * @nullable
   */
  updated_at?: string | null;
}

export const v1ProjectStatsRetrieve = (
  accountId: string,
  projectId: string,
  params?: V1ProjectStatsRetrieveParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<void>> => {
  return axios.get(`/api/v1/${accountId}/${projectId}/project-stats`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getV1ProjectStatsRetrieveKey = (
  accountId: string,
  projectId: string,
  params?: V1ProjectStatsRetrieveParams,
) =>
  [
    `/api/v1/${accountId}/${projectId}/project-stats`,
    ...(params ? [params] : []),
  ] as const;

export type V1ProjectStatsRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof v1ProjectStatsRetrieve>>
>;
export type V1ProjectStatsRetrieveQueryError = AxiosError<void>;

export const useV1ProjectStatsRetrieve = <TError = AxiosError<void>>(
  accountId: string,
  projectId: string,
  params?: V1ProjectStatsRetrieveParams,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof v1ProjectStatsRetrieve>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
    axios?: AxiosRequestConfig;
  },
) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!(accountId && projectId);
  const swrKey =
    swrOptions?.swrKey ??
    (() =>
      isEnabled
        ? getV1ProjectStatsRetrieveKey(accountId, projectId, params)
        : null);
  const swrFn = () =>
    v1ProjectStatsRetrieve(accountId, projectId, params, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

export const v1ProjectsRetrieve2 = (
  accountId: string,
  params?: V1ProjectsRetrieve2Params,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedProjectsResponse>> => {
  return axios.get(`/api/v1/${accountId}/projects`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getV1ProjectsRetrieve2Key = (
  accountId: string,
  params?: V1ProjectsRetrieve2Params,
) => [`/api/v1/${accountId}/projects`, ...(params ? [params] : [])] as const;

export type V1ProjectsRetrieve2QueryResult = NonNullable<
  Awaited<ReturnType<typeof v1ProjectsRetrieve2>>
>;
export type V1ProjectsRetrieve2QueryError = AxiosError<void>;

export const useV1ProjectsRetrieve2 = <TError = AxiosError<void>>(
  accountId: string,
  params?: V1ProjectsRetrieve2Params,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof v1ProjectsRetrieve2>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
    axios?: AxiosRequestConfig;
  },
) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!accountId;
  const swrKey =
    swrOptions?.swrKey ??
    (() => (isEnabled ? getV1ProjectsRetrieve2Key(accountId, params) : null));
  const swrFn = () => v1ProjectsRetrieve2(accountId, params, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

export const v1AccountsRetrieve = (
  params?: V1AccountsRetrieveParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedAccountsResponse>> => {
  return axios.get(`/api/v1/accounts`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getV1AccountsRetrieveKey = (params?: V1AccountsRetrieveParams) =>
  [`/api/v1/accounts`, ...(params ? [params] : [])] as const;

export type V1AccountsRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof v1AccountsRetrieve>>
>;
export type V1AccountsRetrieveQueryError = AxiosError<void>;

export const useV1AccountsRetrieve = <TError = AxiosError<void>>(
  params?: V1AccountsRetrieveParams,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof v1AccountsRetrieve>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
    axios?: AxiosRequestConfig;
  },
) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey =
    swrOptions?.swrKey ??
    (() => (isEnabled ? getV1AccountsRetrieveKey(params) : null));
  const swrFn = () => v1AccountsRetrieve(params, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

export const v1AccountsRetrieve2 = (
  accountId: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<Account>> => {
  return axios.get(`/api/v1/accounts/${accountId}`, options);
};

export const getV1AccountsRetrieve2Key = (accountId: string) =>
  [`/api/v1/accounts/${accountId}`] as const;

export type V1AccountsRetrieve2QueryResult = NonNullable<
  Awaited<ReturnType<typeof v1AccountsRetrieve2>>
>;
export type V1AccountsRetrieve2QueryError = AxiosError<void>;

export const useV1AccountsRetrieve2 = <TError = AxiosError<void>>(
  accountId: string,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof v1AccountsRetrieve2>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
    axios?: AxiosRequestConfig;
  },
) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!accountId;
  const swrKey =
    swrOptions?.swrKey ??
    (() => (isEnabled ? getV1AccountsRetrieve2Key(accountId) : null));
  const swrFn = () => v1AccountsRetrieve2(accountId, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

export const v1AccountsActivePotsRetrieve = (
  accountId: string,
  params?: V1AccountsActivePotsRetrieveParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedPotsResponse>> => {
  return axios.get(`/api/v1/accounts/${accountId}/active_pots`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getV1AccountsActivePotsRetrieveKey = (
  accountId: string,
  params?: V1AccountsActivePotsRetrieveParams,
) =>
  [
    `/api/v1/accounts/${accountId}/active_pots`,
    ...(params ? [params] : []),
  ] as const;

export type V1AccountsActivePotsRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof v1AccountsActivePotsRetrieve>>
>;
export type V1AccountsActivePotsRetrieveQueryError = AxiosError<void>;

export const useV1AccountsActivePotsRetrieve = <TError = AxiosError<void>>(
  accountId: string,
  params?: V1AccountsActivePotsRetrieveParams,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof v1AccountsActivePotsRetrieve>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
    axios?: AxiosRequestConfig;
  },
) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!accountId;
  const swrKey =
    swrOptions?.swrKey ??
    (() =>
      isEnabled ? getV1AccountsActivePotsRetrieveKey(accountId, params) : null);
  const swrFn = () =>
    v1AccountsActivePotsRetrieve(accountId, params, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

export const v1AccountsDonationsReceivedRetrieve = (
  accountId: string,
  params?: V1AccountsDonationsReceivedRetrieveParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedDonationsResponse>> => {
  return axios.get(`/api/v1/accounts/${accountId}/donations_received`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getV1AccountsDonationsReceivedRetrieveKey = (
  accountId: string,
  params?: V1AccountsDonationsReceivedRetrieveParams,
) =>
  [
    `/api/v1/accounts/${accountId}/donations_received`,
    ...(params ? [params] : []),
  ] as const;

export type V1AccountsDonationsReceivedRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof v1AccountsDonationsReceivedRetrieve>>
>;
export type V1AccountsDonationsReceivedRetrieveQueryError = AxiosError<void>;

export const useV1AccountsDonationsReceivedRetrieve = <
  TError = AxiosError<void>,
>(
  accountId: string,
  params?: V1AccountsDonationsReceivedRetrieveParams,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof v1AccountsDonationsReceivedRetrieve>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
    axios?: AxiosRequestConfig;
  },
) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!accountId;
  const swrKey =
    swrOptions?.swrKey ??
    (() =>
      isEnabled
        ? getV1AccountsDonationsReceivedRetrieveKey(accountId, params)
        : null);
  const swrFn = () =>
    v1AccountsDonationsReceivedRetrieve(accountId, params, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

export const v1AccountsDonationsSentRetrieve = (
  accountId: string,
  params?: V1AccountsDonationsSentRetrieveParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedDonationsResponse>> => {
  return axios.get(`/api/v1/accounts/${accountId}/donations_sent`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getV1AccountsDonationsSentRetrieveKey = (
  accountId: string,
  params?: V1AccountsDonationsSentRetrieveParams,
) =>
  [
    `/api/v1/accounts/${accountId}/donations_sent`,
    ...(params ? [params] : []),
  ] as const;

export type V1AccountsDonationsSentRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof v1AccountsDonationsSentRetrieve>>
>;
export type V1AccountsDonationsSentRetrieveQueryError = AxiosError<void>;

export const useV1AccountsDonationsSentRetrieve = <TError = AxiosError<void>>(
  accountId: string,
  params?: V1AccountsDonationsSentRetrieveParams,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof v1AccountsDonationsSentRetrieve>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
    axios?: AxiosRequestConfig;
  },
) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!accountId;
  const swrKey =
    swrOptions?.swrKey ??
    (() =>
      isEnabled
        ? getV1AccountsDonationsSentRetrieveKey(accountId, params)
        : null);
  const swrFn = () =>
    v1AccountsDonationsSentRetrieve(accountId, params, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

export const v1AccountsListRegistrationsRetrieve = (
  accountId: string,
  params?: V1AccountsListRegistrationsRetrieveParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedListRegistrationsResponse>> => {
  return axios.get(`/api/v1/accounts/${accountId}/list-registrations`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getV1AccountsListRegistrationsRetrieveKey = (
  accountId: string,
  params?: V1AccountsListRegistrationsRetrieveParams,
) =>
  [
    `/api/v1/accounts/${accountId}/list-registrations`,
    ...(params ? [params] : []),
  ] as const;

export type V1AccountsListRegistrationsRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof v1AccountsListRegistrationsRetrieve>>
>;
export type V1AccountsListRegistrationsRetrieveQueryError = AxiosError<void>;

export const useV1AccountsListRegistrationsRetrieve = <
  TError = AxiosError<void>,
>(
  accountId: string,
  params?: V1AccountsListRegistrationsRetrieveParams,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof v1AccountsListRegistrationsRetrieve>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
    axios?: AxiosRequestConfig;
  },
) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!accountId;
  const swrKey =
    swrOptions?.swrKey ??
    (() =>
      isEnabled
        ? getV1AccountsListRegistrationsRetrieveKey(accountId, params)
        : null);
  const swrFn = () =>
    v1AccountsListRegistrationsRetrieve(accountId, params, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

export const v1AccountsPayoutsReceivedRetrieve = (
  accountId: string,
  params?: V1AccountsPayoutsReceivedRetrieveParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedPotPayoutsResponse>> => {
  return axios.get(`/api/v1/accounts/${accountId}/payouts_received`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getV1AccountsPayoutsReceivedRetrieveKey = (
  accountId: string,
  params?: V1AccountsPayoutsReceivedRetrieveParams,
) =>
  [
    `/api/v1/accounts/${accountId}/payouts_received`,
    ...(params ? [params] : []),
  ] as const;

export type V1AccountsPayoutsReceivedRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof v1AccountsPayoutsReceivedRetrieve>>
>;
export type V1AccountsPayoutsReceivedRetrieveQueryError = AxiosError<void>;

export const useV1AccountsPayoutsReceivedRetrieve = <TError = AxiosError<void>>(
  accountId: string,
  params?: V1AccountsPayoutsReceivedRetrieveParams,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof v1AccountsPayoutsReceivedRetrieve>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
    axios?: AxiosRequestConfig;
  },
) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!accountId;
  const swrKey =
    swrOptions?.swrKey ??
    (() =>
      isEnabled
        ? getV1AccountsPayoutsReceivedRetrieveKey(accountId, params)
        : null);
  const swrFn = () =>
    v1AccountsPayoutsReceivedRetrieve(accountId, params, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

export const v1AccountsPotApplicationsRetrieve = (
  accountId: string,
  params?: V1AccountsPotApplicationsRetrieveParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedPotApplicationsResponse>> => {
  return axios.get(`/api/v1/accounts/${accountId}/pot_applications`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getV1AccountsPotApplicationsRetrieveKey = (
  accountId: string,
  params?: V1AccountsPotApplicationsRetrieveParams,
) =>
  [
    `/api/v1/accounts/${accountId}/pot_applications`,
    ...(params ? [params] : []),
  ] as const;

export type V1AccountsPotApplicationsRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof v1AccountsPotApplicationsRetrieve>>
>;
export type V1AccountsPotApplicationsRetrieveQueryError = AxiosError<void>;

export const useV1AccountsPotApplicationsRetrieve = <TError = AxiosError<void>>(
  accountId: string,
  params?: V1AccountsPotApplicationsRetrieveParams,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof v1AccountsPotApplicationsRetrieve>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
    axios?: AxiosRequestConfig;
  },
) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!accountId;
  const swrKey =
    swrOptions?.swrKey ??
    (() =>
      isEnabled
        ? getV1AccountsPotApplicationsRetrieveKey(accountId, params)
        : null);
  const swrFn = () =>
    v1AccountsPotApplicationsRetrieve(accountId, params, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

export const v1AccountsUpvotedListsRetrieve = (
  accountId: string,
  params?: V1AccountsUpvotedListsRetrieveParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedListsResponse>> => {
  return axios.get(`/api/v1/accounts/${accountId}/upvoted-lists`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getV1AccountsUpvotedListsRetrieveKey = (
  accountId: string,
  params?: V1AccountsUpvotedListsRetrieveParams,
) =>
  [
    `/api/v1/accounts/${accountId}/upvoted-lists`,
    ...(params ? [params] : []),
  ] as const;

export type V1AccountsUpvotedListsRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof v1AccountsUpvotedListsRetrieve>>
>;
export type V1AccountsUpvotedListsRetrieveQueryError = AxiosError<void>;

export const useV1AccountsUpvotedListsRetrieve = <TError = AxiosError<void>>(
  accountId: string,
  params?: V1AccountsUpvotedListsRetrieveParams,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof v1AccountsUpvotedListsRetrieve>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
    axios?: AxiosRequestConfig;
  },
) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!accountId;
  const swrKey =
    swrOptions?.swrKey ??
    (() =>
      isEnabled
        ? getV1AccountsUpvotedListsRetrieveKey(accountId, params)
        : null);
  const swrFn = () =>
    v1AccountsUpvotedListsRetrieve(accountId, params, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

export const v1DonateContractConfigRetrieve = (
  params?: V1DonateContractConfigRetrieveParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<DonationContractConfig>> => {
  return axios.get(`/api/v1/donate_contract_config`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getV1DonateContractConfigRetrieveKey = (
  params?: V1DonateContractConfigRetrieveParams,
) => [`/api/v1/donate_contract_config`, ...(params ? [params] : [])] as const;

export type V1DonateContractConfigRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof v1DonateContractConfigRetrieve>>
>;
export type V1DonateContractConfigRetrieveQueryError = AxiosError<void>;

export const useV1DonateContractConfigRetrieve = <TError = AxiosError<void>>(
  params?: V1DonateContractConfigRetrieveParams,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof v1DonateContractConfigRetrieve>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
    axios?: AxiosRequestConfig;
  },
) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey =
    swrOptions?.swrKey ??
    (() => (isEnabled ? getV1DonateContractConfigRetrieveKey(params) : null));
  const swrFn = () => v1DonateContractConfigRetrieve(params, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

export const v1DonorsRetrieve = (
  params?: V1DonorsRetrieveParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedAccountsResponse>> => {
  return axios.get(`/api/v1/donors`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getV1DonorsRetrieveKey = (params?: V1DonorsRetrieveParams) =>
  [`/api/v1/donors`, ...(params ? [params] : [])] as const;

export type V1DonorsRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof v1DonorsRetrieve>>
>;
export type V1DonorsRetrieveQueryError = AxiosError<void>;

export const useV1DonorsRetrieve = <TError = AxiosError<void>>(
  params?: V1DonorsRetrieveParams,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof v1DonorsRetrieve>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
    axios?: AxiosRequestConfig;
  },
) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey =
    swrOptions?.swrKey ??
    (() => (isEnabled ? getV1DonorsRetrieveKey(params) : null));
  const swrFn = () => v1DonorsRetrieve(params, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

export const v1ListsRetrieve = (
  params?: V1ListsRetrieveParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedListsResponse>> => {
  return axios.get(`/api/v1/lists`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getV1ListsRetrieveKey = (params?: V1ListsRetrieveParams) =>
  [`/api/v1/lists`, ...(params ? [params] : [])] as const;

export type V1ListsRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof v1ListsRetrieve>>
>;
export type V1ListsRetrieveQueryError = AxiosError<void>;

export const useV1ListsRetrieve = <TError = AxiosError<void>>(
  params?: V1ListsRetrieveParams,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof v1ListsRetrieve>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
    axios?: AxiosRequestConfig;
  },
) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey =
    swrOptions?.swrKey ??
    (() => (isEnabled ? getV1ListsRetrieveKey(params) : null));
  const swrFn = () => v1ListsRetrieve(params, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

export const v1ListsRetrieve2 = (
  listId: number,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<List>> => {
  return axios.get(`/api/v1/lists/${listId}`, options);
};

export const getV1ListsRetrieve2Key = (listId: number) =>
  [`/api/v1/lists/${listId}`] as const;

export type V1ListsRetrieve2QueryResult = NonNullable<
  Awaited<ReturnType<typeof v1ListsRetrieve2>>
>;
export type V1ListsRetrieve2QueryError = AxiosError<void>;

export const useV1ListsRetrieve2 = <TError = AxiosError<void>>(
  listId: number,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof v1ListsRetrieve2>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
    axios?: AxiosRequestConfig;
  },
) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!listId;
  const swrKey =
    swrOptions?.swrKey ??
    (() => (isEnabled ? getV1ListsRetrieve2Key(listId) : null));
  const swrFn = () => v1ListsRetrieve2(listId, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

export const v1ListsRandomRegistrationRetrieve = (
  listId: number,
  params?: V1ListsRandomRegistrationRetrieveParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<ListRegistration>> => {
  return axios.get(`/api/v1/lists/${listId}/random_registration`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getV1ListsRandomRegistrationRetrieveKey = (
  listId: number,
  params?: V1ListsRandomRegistrationRetrieveParams,
) =>
  [
    `/api/v1/lists/${listId}/random_registration`,
    ...(params ? [params] : []),
  ] as const;

export type V1ListsRandomRegistrationRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof v1ListsRandomRegistrationRetrieve>>
>;
export type V1ListsRandomRegistrationRetrieveQueryError = AxiosError<void>;

export const useV1ListsRandomRegistrationRetrieve = <TError = AxiosError<void>>(
  listId: number,
  params?: V1ListsRandomRegistrationRetrieveParams,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof v1ListsRandomRegistrationRetrieve>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
    axios?: AxiosRequestConfig;
  },
) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!listId;
  const swrKey =
    swrOptions?.swrKey ??
    (() =>
      isEnabled
        ? getV1ListsRandomRegistrationRetrieveKey(listId, params)
        : null);
  const swrFn = () =>
    v1ListsRandomRegistrationRetrieve(listId, params, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

export const v1ListsRegistrationsRetrieve = (
  listId: number,
  params?: V1ListsRegistrationsRetrieveParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedListRegistrationsResponse>> => {
  return axios.get(`/api/v1/lists/${listId}/registrations`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getV1ListsRegistrationsRetrieveKey = (
  listId: number,
  params?: V1ListsRegistrationsRetrieveParams,
) =>
  [
    `/api/v1/lists/${listId}/registrations`,
    ...(params ? [params] : []),
  ] as const;

export type V1ListsRegistrationsRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof v1ListsRegistrationsRetrieve>>
>;
export type V1ListsRegistrationsRetrieveQueryError = AxiosError<void>;

export const useV1ListsRegistrationsRetrieve = <TError = AxiosError<void>>(
  listId: number,
  params?: V1ListsRegistrationsRetrieveParams,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof v1ListsRegistrationsRetrieve>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
    axios?: AxiosRequestConfig;
  },
) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!listId;
  const swrKey =
    swrOptions?.swrKey ??
    (() =>
      isEnabled ? getV1ListsRegistrationsRetrieveKey(listId, params) : null);
  const swrFn = () =>
    v1ListsRegistrationsRetrieve(listId, params, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

export const v1PotfactoriesRetrieve = (
  params?: V1PotfactoriesRetrieveParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedPotFactoriesResponse>> => {
  return axios.get(`/api/v1/potfactories`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getV1PotfactoriesRetrieveKey = (
  params?: V1PotfactoriesRetrieveParams,
) => [`/api/v1/potfactories`, ...(params ? [params] : [])] as const;

export type V1PotfactoriesRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof v1PotfactoriesRetrieve>>
>;
export type V1PotfactoriesRetrieveQueryError = AxiosError<unknown>;

export const useV1PotfactoriesRetrieve = <TError = AxiosError<unknown>>(
  params?: V1PotfactoriesRetrieveParams,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof v1PotfactoriesRetrieve>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
    axios?: AxiosRequestConfig;
  },
) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey =
    swrOptions?.swrKey ??
    (() => (isEnabled ? getV1PotfactoriesRetrieveKey(params) : null));
  const swrFn = () => v1PotfactoriesRetrieve(params, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

export const v1PotsRetrieve = (
  params?: V1PotsRetrieveParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedPotsResponse>> => {
  return axios.get(`/api/v1/pots`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getV1PotsRetrieveKey = (params?: V1PotsRetrieveParams) =>
  [`/api/v1/pots`, ...(params ? [params] : [])] as const;

export type V1PotsRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof v1PotsRetrieve>>
>;
export type V1PotsRetrieveQueryError = AxiosError<unknown>;

export const useV1PotsRetrieve = <TError = AxiosError<unknown>>(
  params?: V1PotsRetrieveParams,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof v1PotsRetrieve>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
    axios?: AxiosRequestConfig;
  },
) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey =
    swrOptions?.swrKey ??
    (() => (isEnabled ? getV1PotsRetrieveKey(params) : null));
  const swrFn = () => v1PotsRetrieve(params, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

export const v1PotsRetrieve2 = (
  potId: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<Pot>> => {
  return axios.get(`/api/v1/pots/${potId}/`, options);
};

export const getV1PotsRetrieve2Key = (potId: string) =>
  [`/api/v1/pots/${potId}/`] as const;

export type V1PotsRetrieve2QueryResult = NonNullable<
  Awaited<ReturnType<typeof v1PotsRetrieve2>>
>;
export type V1PotsRetrieve2QueryError = AxiosError<void>;

export const useV1PotsRetrieve2 = <TError = AxiosError<void>>(
  potId: string,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof v1PotsRetrieve2>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
    axios?: AxiosRequestConfig;
  },
) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!potId;
  const swrKey =
    swrOptions?.swrKey ??
    (() => (isEnabled ? getV1PotsRetrieve2Key(potId) : null));
  const swrFn = () => v1PotsRetrieve2(potId, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

export const v1PotsApplicationsRetrieve = (
  potId: string,
  params?: V1PotsApplicationsRetrieveParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedPotApplicationsResponse>> => {
  return axios.get(`/api/v1/pots/${potId}/applications`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getV1PotsApplicationsRetrieveKey = (
  potId: string,
  params?: V1PotsApplicationsRetrieveParams,
) =>
  [`/api/v1/pots/${potId}/applications`, ...(params ? [params] : [])] as const;

export type V1PotsApplicationsRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof v1PotsApplicationsRetrieve>>
>;
export type V1PotsApplicationsRetrieveQueryError = AxiosError<void>;

export const useV1PotsApplicationsRetrieve = <TError = AxiosError<void>>(
  potId: string,
  params?: V1PotsApplicationsRetrieveParams,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof v1PotsApplicationsRetrieve>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
    axios?: AxiosRequestConfig;
  },
) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!potId;
  const swrKey =
    swrOptions?.swrKey ??
    (() =>
      isEnabled ? getV1PotsApplicationsRetrieveKey(potId, params) : null);
  const swrFn = () => v1PotsApplicationsRetrieve(potId, params, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

export const v1PotsDonationsRetrieve = (
  potId: string,
  params?: V1PotsDonationsRetrieveParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedDonationsResponse>> => {
  return axios.get(`/api/v1/pots/${potId}/donations`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getV1PotsDonationsRetrieveKey = (
  potId: string,
  params?: V1PotsDonationsRetrieveParams,
) => [`/api/v1/pots/${potId}/donations`, ...(params ? [params] : [])] as const;

export type V1PotsDonationsRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof v1PotsDonationsRetrieve>>
>;
export type V1PotsDonationsRetrieveQueryError = AxiosError<void>;

export const useV1PotsDonationsRetrieve = <TError = AxiosError<void>>(
  potId: string,
  params?: V1PotsDonationsRetrieveParams,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof v1PotsDonationsRetrieve>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
    axios?: AxiosRequestConfig;
  },
) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!potId;
  const swrKey =
    swrOptions?.swrKey ??
    (() => (isEnabled ? getV1PotsDonationsRetrieveKey(potId, params) : null));
  const swrFn = () => v1PotsDonationsRetrieve(potId, params, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

export const v1PotsPayoutsRetrieve = (
  potId: string,
  params?: V1PotsPayoutsRetrieveParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedPotPayoutsResponse>> => {
  return axios.get(`/api/v1/pots/${potId}/payouts`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getV1PotsPayoutsRetrieveKey = (
  potId: string,
  params?: V1PotsPayoutsRetrieveParams,
) => [`/api/v1/pots/${potId}/payouts`, ...(params ? [params] : [])] as const;

export type V1PotsPayoutsRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof v1PotsPayoutsRetrieve>>
>;
export type V1PotsPayoutsRetrieveQueryError = AxiosError<void>;

export const useV1PotsPayoutsRetrieve = <TError = AxiosError<void>>(
  potId: string,
  params?: V1PotsPayoutsRetrieveParams,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof v1PotsPayoutsRetrieve>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
    axios?: AxiosRequestConfig;
  },
) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!potId;
  const swrKey =
    swrOptions?.swrKey ??
    (() => (isEnabled ? getV1PotsPayoutsRetrieveKey(potId, params) : null));
  const swrFn = () => v1PotsPayoutsRetrieve(potId, params, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

export const v1PotsSponsorsRetrieve = (
  potId: string,
  params?: V1PotsSponsorsRetrieveParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedAccountsResponse>> => {
  return axios.get(`/api/v1/pots/${potId}/sponsors`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getV1PotsSponsorsRetrieveKey = (
  potId: string,
  params?: V1PotsSponsorsRetrieveParams,
) => [`/api/v1/pots/${potId}/sponsors`, ...(params ? [params] : [])] as const;

export type V1PotsSponsorsRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof v1PotsSponsorsRetrieve>>
>;
export type V1PotsSponsorsRetrieveQueryError = AxiosError<void>;

export const useV1PotsSponsorsRetrieve = <TError = AxiosError<void>>(
  potId: string,
  params?: V1PotsSponsorsRetrieveParams,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof v1PotsSponsorsRetrieve>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
    axios?: AxiosRequestConfig;
  },
) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!potId;
  const swrKey =
    swrOptions?.swrKey ??
    (() => (isEnabled ? getV1PotsSponsorsRetrieveKey(potId, params) : null));
  const swrFn = () => v1PotsSponsorsRetrieve(potId, params, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

export const v1ProjectsRetrieve = (
  params?: V1ProjectsRetrieveParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedProjectsResponse>> => {
  return axios.get(`/api/v1/projects`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getV1ProjectsRetrieveKey = (params?: V1ProjectsRetrieveParams) =>
  [`/api/v1/projects`, ...(params ? [params] : [])] as const;

export type V1ProjectsRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof v1ProjectsRetrieve>>
>;
export type V1ProjectsRetrieveQueryError = AxiosError<void>;

export const useV1ProjectsRetrieve = <TError = AxiosError<void>>(
  params?: V1ProjectsRetrieveParams,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof v1ProjectsRetrieve>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
    axios?: AxiosRequestConfig;
  },
) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey =
    swrOptions?.swrKey ??
    (() => (isEnabled ? getV1ProjectsRetrieveKey(params) : null));
  const swrFn = () => v1ProjectsRetrieve(params, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

export const v1RoundRetrieve = (
  roundId: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<Round>> => {
  return axios.get(`/api/v1/round/${roundId}/`, options);
};

export const getV1RoundRetrieveKey = (roundId: string) =>
  [`/api/v1/round/${roundId}/`] as const;

export type V1RoundRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof v1RoundRetrieve>>
>;
export type V1RoundRetrieveQueryError = AxiosError<void>;

export const useV1RoundRetrieve = <TError = AxiosError<void>>(
  roundId: string,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof v1RoundRetrieve>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
    axios?: AxiosRequestConfig;
  },
) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!roundId;
  const swrKey =
    swrOptions?.swrKey ??
    (() => (isEnabled ? getV1RoundRetrieveKey(roundId) : null));
  const swrFn = () => v1RoundRetrieve(roundId, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

export const v1RoundVotesRetrieve = (
  roundId: string,
  projectId: string,
  params?: V1RoundVotesRetrieveParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedVotesResponse>> => {
  return axios.get(`/api/v1/round/${roundId}/${projectId}/votes`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getV1RoundVotesRetrieveKey = (
  roundId: string,
  projectId: string,
  params?: V1RoundVotesRetrieveParams,
) =>
  [
    `/api/v1/round/${roundId}/${projectId}/votes`,
    ...(params ? [params] : []),
  ] as const;

export type V1RoundVotesRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof v1RoundVotesRetrieve>>
>;
export type V1RoundVotesRetrieveQueryError = AxiosError<void>;

export const useV1RoundVotesRetrieve = <TError = AxiosError<void>>(
  roundId: string,
  projectId: string,
  params?: V1RoundVotesRetrieveParams,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof v1RoundVotesRetrieve>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
    axios?: AxiosRequestConfig;
  },
) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!(roundId && projectId);
  const swrKey =
    swrOptions?.swrKey ??
    (() =>
      isEnabled
        ? getV1RoundVotesRetrieveKey(roundId, projectId, params)
        : null);
  const swrFn = () =>
    v1RoundVotesRetrieve(roundId, projectId, params, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

export const v1RoundsRetrieve = (
  params?: V1RoundsRetrieveParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedRoundsResponse>> => {
  return axios.get(`/api/v1/rounds`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getV1RoundsRetrieveKey = (params?: V1RoundsRetrieveParams) =>
  [`/api/v1/rounds`, ...(params ? [params] : [])] as const;

export type V1RoundsRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof v1RoundsRetrieve>>
>;
export type V1RoundsRetrieveQueryError = AxiosError<void>;

export const useV1RoundsRetrieve = <TError = AxiosError<void>>(
  params?: V1RoundsRetrieveParams,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof v1RoundsRetrieve>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
    axios?: AxiosRequestConfig;
  },
) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey =
    swrOptions?.swrKey ??
    (() => (isEnabled ? getV1RoundsRetrieveKey(params) : null));
  const swrFn = () => v1RoundsRetrieve(params, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

export const v1RoundsApplicationsRetrieve = (
  roundId: string,
  params?: V1RoundsApplicationsRetrieveParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedRoundApplicationsResponse>> => {
  return axios.get(`/api/v1/rounds/${roundId}/applications`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getV1RoundsApplicationsRetrieveKey = (
  roundId: string,
  params?: V1RoundsApplicationsRetrieveParams,
) =>
  [
    `/api/v1/rounds/${roundId}/applications`,
    ...(params ? [params] : []),
  ] as const;

export type V1RoundsApplicationsRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof v1RoundsApplicationsRetrieve>>
>;
export type V1RoundsApplicationsRetrieveQueryError = AxiosError<void>;

export const useV1RoundsApplicationsRetrieve = <TError = AxiosError<void>>(
  roundId: string,
  params?: V1RoundsApplicationsRetrieveParams,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof v1RoundsApplicationsRetrieve>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
    axios?: AxiosRequestConfig;
  },
) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!roundId;
  const swrKey =
    swrOptions?.swrKey ??
    (() =>
      isEnabled ? getV1RoundsApplicationsRetrieveKey(roundId, params) : null);
  const swrFn = () =>
    v1RoundsApplicationsRetrieve(roundId, params, axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

export const v1StatsRetrieve = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<StatsResponse>> => {
  return axios.get(`/api/v1/stats`, options);
};

export const getV1StatsRetrieveKey = () => [`/api/v1/stats`] as const;

export type V1StatsRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof v1StatsRetrieve>>
>;
export type V1StatsRetrieveQueryError = AxiosError<void>;

export const useV1StatsRetrieve = <TError = AxiosError<void>>(options?: {
  swr?: SWRConfiguration<
    Awaited<ReturnType<typeof v1StatsRetrieve>>,
    TError
  > & { swrKey?: Key; enabled?: boolean };
  axios?: AxiosRequestConfig;
}) => {
  const { swr: swrOptions, axios: axiosOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey =
    swrOptions?.swrKey ?? (() => (isEnabled ? getV1StatsRetrieveKey() : null));
  const swrFn = () => v1StatsRetrieve(axiosOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};
